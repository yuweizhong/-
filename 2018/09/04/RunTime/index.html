<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> RunTime · YuWeizhong</title><meta name="description" content="RunTime - YuWeizhong"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/yu.github.io/favicon.png"><link rel="stylesheet" href="/yu.github.io/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://yuweizhong.github.io/yu.github.io/atom.xml" title="YuWeizhong"></head><body><div class="wrap"><header><a href="/yu.github.io/" class="logo-link"><img src="/yu.github.io/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/yu.github.io/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/yu.github.io/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/u/3537156417" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/yuweizhong" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/yu.github.io/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">RunTime</h1><div class="post-info">2018年9月4日</div><div class="post-content"><h1 id="RunTime"><a href="#RunTime" class="headerlink" title="RunTime"></a>RunTime</h1><p>RunTime，简称运行时，是用C和汇编编写的一套底层API，是Objective-C面向对象和动态机制的基础。<br><a href="https://opensource.apple.com/source/objc4/" target="_blank" rel="external">开放源码地址</a></p>
<p><a href="https://developer.apple.com/documentation/objectivec/objective_c_runtime#//apple_ref/doc/uid/TP40001418-CH1g-126286" target="_blank" rel="external">API地址</a></p>
<h2 id="1-类实例（objc-object"><a href="#1-类实例（objc-object" class="headerlink" title="1.类实例（objc_object)"></a>1.类实例（objc_object)</h2><p>objc_object结构体定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct objc_object &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/// A pointer to an instance of a class.</div><div class="line">typedef struct objc_object *id;</div></pre></td></tr></table></figure>
<p>类实例的isa指针指向其所在类对象</p>
<h2 id="2-类对象（objc-class）"><a href="#2-类对象（objc-class）" class="headerlink" title="2.类对象（objc_class）"></a>2.类对象（objc_class）</h2><p>objc_class结构体定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_class *Class;</div><div class="line"></div><div class="line">struct objc_class &#123;</div><div class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</div><div class="line"></div><div class="line">#if !__OBJC2__</div><div class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;     //父类指针</div><div class="line">    const char * _Nonnull name                               OBJC2_UNAVAILABLE;     //类名字</div><div class="line">    long version                                             OBJC2_UNAVAILABLE;     //版本</div><div class="line">    long info                                                OBJC2_UNAVAILABLE;     //信息</div><div class="line">    long instance_size                                       OBJC2_UNAVAILABLE;     //实例大小</div><div class="line">    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;     //变量列表</div><div class="line">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE; //方法列表</div><div class="line">    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;     //缓存</div><div class="line">    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;     //遵守的协议列表</div><div class="line">#endif</div><div class="line"></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure></p>
<p>struct objc_class结构体定义了很多变量（标注如上），类对象就是一个结构体struct objc_class，这个结构体存放的数据称为元数据(metadata)，<br>对象中的元数据存储的都是如何创建一个实例的相关信息，那么类对象和类方法应该从哪里创建呢？<br>就是从isa指针指向的结构体创建，类对象的isa指针指向的我们称之为元类(metaclass)，元类中保存了创建类对象以及类方法所需的所有信息。</p>
<h2 id="3-元类（Meta-Class）"><a href="#3-元类（Meta-Class）" class="headerlink" title="3.元类（Meta Class）"></a>3.元类（Meta Class）</h2><p>元类(Meta Class)是一个类对象的类。所有的类自身也是一个对象，我们可以向这个对象发送消息(即调用类方法)。<br>为了调用类方法，这个类的isa指针必须指向一个包含这些类方法的一个objc_class结构体。这就引出了meta-class的概念，元类中保存了创建类对象以及类方法所需的所有信息。<br>任何NSObject继承体系下的meta-class都使用NSObject的meta-class作为自己的所属类，而基类的meta-class的isa指针是指向它自己。</p>
<p>类实例，类对象和元类的整个结构图所示:<br><img src="http://note.youdao.com/favicon.ico" alt="image"><br>通过上图我们可以看出整个体系构成了一个自闭环，struct objc_object结构体实例它的isa指针指向类对象，<br>类对象的isa指针指向了元类，super_class指针指向了父类的类对象，<br>而元类的super_class指针指向了父类的元类，那元类的isa指针又指向了自己。</p>
<h2 id="4-Method-objc-method"><a href="#4-Method-objc-method" class="headerlink" title="4.Method(objc_method)"></a>4.Method(objc_method)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">runtime.h</div><div class="line">/// An opaque type that represents a method in a class definition.代表类定义中一个方法的不透明类型</div><div class="line">typedef struct objc_method *Method;</div><div class="line">struct objc_method &#123;</div><div class="line">    SEL method_name                  OBJC2_UNAVAILABLE;  //方法名</div><div class="line">    char *method_types               OBJC2_UNAVAILABLE;  //方法类型</div><div class="line">    IMP method_imp                   OBJC2_UNAVAILABLE;  //方法实现</div></pre></td></tr></table></figure>
<pre><code>其中 SEL和IMP其实都是Method的属性。
</code></pre><h3 id="SEL-object-selector"><a href="#SEL-object-selector" class="headerlink" title="SEL(object_selector)"></a>SEL(object_selector)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Objc.h</div><div class="line">/// An opaque type that represents a method selector.代表一个方法的不透明类型</div><div class="line">typedef struct objc_selector *SEL;</div></pre></td></tr></table></figure>
<p>selector是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是SEL,selector是SEL的一个实例.</p>
<blockquote>
<p>同一个类，selector不能重复<br>不同的类，selector可以重复</p>
</blockquote>
<h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/// A pointer to the function of a method implementation.  指向一个方法实现的指针</div><div class="line">typedef id (*IMP)(id, SEL, ...); </div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>指向最终实现程序的内存地址的指针</p>
<h2 id="类缓存（object-cache"><a href="#类缓存（object-cache" class="headerlink" title="类缓存（object_cache)"></a>类缓存（object_cache)</h2><p>当Objective-C运行时通过跟踪它的isa指针检查对象时，它可以找到一个实现许多方法的对象。然而，你可能只调用它们的一小部分，并且每次查找时，搜索所有选择器的类分派表没有意义。所以类实现一个缓存，每当你搜索一个类分派表，并找到相应的选择器，它把它放入它的缓存。所以当objc_msgSend查找一个类的选择器，它首先搜索类缓存。这是基于这样的理论：如果你在类上调用一个消息，你可能以后再次调用该消息。<br>为了加速消息分发， 系统会对方法和对应的地址进行缓存，就放在上述的objc_cache，所以在实际运行中，大部分常用的方法都是会被缓存起来的，Runtime系统实际上非常快，接近直接执行内存地址的程序速度。</p>
<h2 id="分类Category（object-category）"><a href="#分类Category（object-category）" class="headerlink" title="分类Category（object_category）"></a>分类Category（object_category）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct category_t &#123; </div><div class="line">    const char *name;                           //className</div><div class="line">    classref_t cls;                             //要扩展的类对象，在runtime阶段通过name对应到类对象</div><div class="line">    struct method_list_t *instanceMethods;      //给类添加的实例方法列表</div><div class="line">    struct method_list_t *classMethods;         //类类添加的类方法列表</div><div class="line">    struct protocol_list_t *protocols;          //实现的所有协议列表</div><div class="line">    struct property_list_t *instanceProperties; //所有属性 非实例变量，通过objc_setAssociatedObject和objc_getAssociatedObject增加</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="一-Runtime-—-消息传递机制"><a href="#一-Runtime-—-消息传递机制" class="headerlink" title="一.Runtime — 消息传递机制"></a>一.Runtime — 消息传递机制</h2><p>在OC中，消息和方法的绑定是在运行时进行的，一个对象的方法像这样[obj foo]，编译器转成消息发送objc_msgSend(obj, foo)。消息传递机制的关键在于编译器对每个类和对象的结构的构建，每个类结构包含两个基本元素：指向父类的指针和类调度表。这个表罗列了他们定义的有明确类特征的方法的地址的方法选择器。</p>
<p><img src="http://note.youdao.com/favicon.ico" alt="image"><br>当一个消息传递给一个对象的时候，消息函数沿着这个对象的isa指针在调度表找到它建立起方法选择器的类结构。如果它不能在这里发现选择器，obic_msgSend根据指针找到它的父类，在父类的调度表中寻找选择器。连续失败导致objc_msgSend沿着类继承结构直到寻找到NSObject类。一旦确定选择器的位置，函数调用表中的方法并且把它传给接收对象的数据结构。</p>
<p>objc_msgSend 方法定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OBJC_EXPORT id objc_msgSend(id self, SEL op, ...)</div></pre></td></tr></table></figure>
<p>具体消息传递在Runtime时执行的流程是这样的（具体类对象/元类的定义可以参见<a href="http://note.youdao.com/" target="_blank" rel="external">这里</a>）：</p>
<ol>
<li>首先，通过obj的isa指针找到它的 class ;</li>
<li>在 class 的 method list 找 foo 方法 ;</li>
<li>如果 class 中没到 foo，继续往它的 superclass 中找 ;</li>
<li>一旦找到 foo 这个函数，就去执行它的实现IMP 。</li>
</ol>
<blockquote>
<p> 但是如果每次都按照这个流程执行的话，会有一个问题：一个class 往往只有 20% 的函数会被经常调用，可能占总调用次数的 80% 。每个消息都需要遍历一次objc_method_list，效率明显低下，很不合理。<br>— 。如果把经常被调用的函数缓存下来，那可以大大提高函数查询的效率。这也就是objc_class 中另一个重要成员objc_cache 做的事情 - 再找到foo 之后，把foo 的method_name 作为key ，method_imp作为value 给存起来。当再次收到foo 消息的时候，可以直接在cache 里找到，避免去遍历objc_method_list。从前面的源代码可以看到objc_cache是存在objc_class 结构体中的。</p>
</blockquote>
<h2 id="二-Runtime-—-消息转发"><a href="#二-Runtime-—-消息转发" class="headerlink" title="二.Runtime — 消息转发"></a>二.Runtime — 消息转发</h2><p><img src="http://note.youdao.com/favicon.ico" alt="image"></p>
<p>由上图可以看到，消息转发中有3次可以调整的机会，防止unrecognized selector报错，</p>
<h3 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h3><p>首先，Objective-C运行时会调用 +resolveInstanceMethod:或者 +resolveClassMethod:，让你有机会提供一个函数实现。如果你添加了函数并返回YES， 那运行时系统就会重新启动一次消息发送的过程。</p>
<h3 id="备用接收者"><a href="#备用接收者" class="headerlink" title="备用接收者"></a>备用接收者</h3><p>如果目标对象实现了-forwardingTargetForSelector:，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。</p>
<h3 id="完整消息转发"><a href="#完整消息转发" class="headerlink" title="完整消息转发"></a>完整消息转发</h3><p>如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。<br>首先它会发送-methodSignatureForSelector:消息获得函数的参数和返回值类型。如果-methodSignatureForSelector:返回nil ，Runtime则会发出 -doesNotRecognizeSelector: 消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation 对象并发送 -forwardInvocation:消息给目标对象。</p>
<p>从打印结果来看，我们实现了完整的转发。通过签名，Runtime生成了一个对象anInvocation，发送给了forwardInvocation，我们在forwardInvocation方法里面让Person对象去执行了foo函数。签名参数v@:怎么解释呢，这里苹果文档Type <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="external">Encodings有详细的解释</a>。<br>以上就是Runtime的三次转发流程。下面我们讲讲Runtime的实际应用。</p>
<p>##RunTime — 应用</p>
<p>关联对象(Objective-C Associated Objects)给分类增加属性<br>方法魔法(Method Swizzling)方法添加和替换和KVO实现<br>消息转发(热更新)解决Bug(JSPatch)<br>实现NSCoding的自动归档和自动解档<br>实现字典和模型的自动转换(MJExtension)</p>
<p>swizzling应该只在+load中完成。 在 Objective-C 的运行时中，每个类有两个方法都会自动调用。+load 是在一个类被初始装载时调用，+initialize 是在应用第一次调用该类的类方法或实例方法前调用的。两个方法都是可选的，并且只有在方法被实现的情况下才会被调用。<br>swizzling应该只在dispatch_once 中完成,由于swizzling 改变了全局的状态，所以我们需要确保每个预防措施在运行时都是可用的。原子操作就是这样一个用于确保代码只会被执行一次的预防措施，就算是在不同的线程中也能确保代码只执行一次。Grand Central Dispatch 的 dispatch_once满足了所需要的需求，并且应该被当做使用swizzling 的初始化单例方法的标准。</p>
</div></article></div></main><footer><div class="paginator"><a href="/yu.github.io/2018/09/06/Toll-Free-Bridged/" class="prev">上一篇</a><a href="/yu.github.io/2018/04/26/iOS 响应者链/" class="next">下一篇</a></div><div class="copyright"><p>© 2017 - 2018 <a href="https://yuweizhong.github.io/yu.github.io">YuWeizhong</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>