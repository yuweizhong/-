<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YuWeizhong</title>
  
  <subtitle>Hope Future , Do Now!!!</subtitle>
  <link href="/yu.github.io/atom.xml" rel="self"/>
  
  <link href="https://yuweizhong.github.io/yu.github.io/"/>
  <updated>2018-03-02T06:44:23.378Z</updated>
  <id>https://yuweizhong.github.io/yu.github.io/</id>
  
  <author>
    <name>YuWeizhong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>resolveInstanceMethod和resolveClassMethod</title>
    <link href="https://yuweizhong.github.io/yu.github.io/2018/03/02/OC%E6%9C%AA%E7%9F%A5%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/"/>
    <id>https://yuweizhong.github.io/yu.github.io/2018/03/02/OC未知消息转发/</id>
    <published>2018-03-02T10:33:15.000Z</published>
    <updated>2018-03-02T06:44:23.378Z</updated>
    
    <content type="html"><![CDATA[<p>在iOS中，消息发送是通过，objc_msgSend(id, SEL, …)来实现的。<br>首先会在对象的类对象的cache,method list以及父类对象的cache,method list依次查找SEL对应的IMP。<br>如果向一个对象发送无法它无法处理的消息，一般会出现crash。</p><p>通过实现动态决议和消息转发。只有当动态决议无法决议selector的实现，才会尝试进行消息转发，可以避免一些crash情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//针对实例方法</div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)name &#123;</div><div class="line"> NSLog(@&quot; &gt;&gt; Instance resolving %@&quot;, NSStringFromSelector(name)); </div><div class="line"> if (name == @selector(MissMethod)) &#123; </div><div class="line"> /*</div><div class="line"> **就能在运行期动态地为 name 这个 selector 添加实现：dynamicMethodIMP。class_addMethod是运行时函数，所以需要导入头文件：objc/runtime.h。</div><div class="line"> */</div><div class="line"> class_addMethod([self class], name, (IMP)dynamicMethodIMP, &quot;v@:&quot;);</div><div class="line">  return YES; &#125; </div><div class="line">  return [super resolveInstanceMethod:name]; </div><div class="line">&#125;</div><div class="line"></div><div class="line">//针对类方法</div><div class="line"> + (BOOL)resolveClassMethod:(SEL)name &#123; </div><div class="line"> NSLog(@&quot; &gt;&gt; Class resolving %@&quot;, NSStringFromSelector(name)); </div><div class="line"> return [super resolveClassMethod:name]; </div><div class="line"> &#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在iOS中，消息发送是通过，objc_msgSend(id, SEL, …)来实现的。&lt;br&gt;首先会在对象的类对象的cache,method list以及父类对象的cache,method list依次查找SEL对应的IMP。&lt;br&gt;如果向一个对象发送无法它无法处理的消息，
      
    
    </summary>
    
    
      <category term="method" scheme="https://yuweizhong.github.io/yu.github.io/tags/method/"/>
    
  </entry>
  
  <entry>
    <title>iOS UI界面搭建方式</title>
    <link href="https://yuweizhong.github.io/yu.github.io/2017/12/02/iOS%20%E7%95%8C%E9%9D%A2%E6%90%AD%E5%BB%BA/"/>
    <id>https://yuweizhong.github.io/yu.github.io/2017/12/02/iOS 界面搭建/</id>
    <published>2017-12-02T04:20:40.000Z</published>
    <updated>2018-01-16T06:27:10.042Z</updated>
    
    <content type="html"><![CDATA[<p>对于iOS界面的搭建，关于使用哪种方式不少人会有一些争议，纯代码、xib或者说是storyboard：</p><p><strong>纯代码</strong><br>纯手写代码，灵活容易控制，对于大型项目和团队开发较为友好，特别是在版本控制和代码管理上面，但是代码量较大，较为繁琐。现阶段很多采用Masonry手写代码布局，配合Reveal工具调试。</p><p><strong>xib&amp;storyboard</strong><br>xib出现在storyboard之前，和storyboard类似，storyboard是各个xib的集合，xib相比storyboard更小规模些。两者都可以实现控件拖拽布局，比较直观，开发较快， storyboard 中可以很方便地理清界面间的调用关系。但是两者对于代码管理不是很友好，不同版本的Xcode打开会造成xib修改，对于冲突的解决也很难看出来。对于复杂的App，storyboard的性能会差一些。</p><p><strong>因此，一般我会采用纯代码和Xib结合的方式：</strong></p><ul><li>对于复杂的、动态生成的界面，建议使用手工编写界面。</li><li>对于需要统一风格的按钮或UI控件，建议使用手工用代码来构造。方便之后的修改和复用。</li><li>对于需要有继承或组合关系的 UIView 类或 UIViewController类，建议用代码手工编写界面。</li><li>对于那些简单的、静态的、非核心功能界面，可以考虑使用 xib 或 storyboard 来完成。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于iOS界面的搭建，关于使用哪种方式不少人会有一些争议，纯代码、xib或者说是storyboard：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;纯代码&lt;/strong&gt;&lt;br&gt;纯手写代码，灵活容易控制，对于大型项目和团队开发较为友好，特别是在版本控制和代码管理上面，但是代码量较大，较
      
    
    </summary>
    
    
      <category term="UI" scheme="https://yuweizhong.github.io/yu.github.io/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>OC Basis</title>
    <link href="https://yuweizhong.github.io/yu.github.io/2017/11/03/OC%20Basis/"/>
    <id>https://yuweizhong.github.io/yu.github.io/2017/11/03/OC Basis/</id>
    <published>2017-11-03T08:41:44.000Z</published>
    <updated>2018-02-23T09:00:12.291Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Objective-C动态时特性"><a href="#1、Objective-C动态时特性" class="headerlink" title="1、Objective-C动态时特性"></a>1、Objective-C动态时特性</h3><pre><code>OC语言动态时的特性主要表现在：动态类型、动态绑定、动态加载。</code></pre><ul><li><p>动态类型，区分于静态类型（int、float…），静态类型在编译时决定变量类型，类型不符合就会报错。动态类型即在运行时决定变量类型，OC中的id类型，任何对象都可以被id类型指针所指，到运行时才决定对象的类型。</p></li><li><p>动态绑定，基于动态类型，在某个实例对象被确定之后，其属性和方法也就被确定了。OC中的方法都是消息转发机制，当我们向一个对象发送息发送-respondsToSelector:或者 -instancesRespondToSelector:等来确定对象是否可以对某个方法做出响应时，在消息转发机制处理之前，对应的类 的+resolveClassMethod:和+resolveInstanceMethod:将会被调用，可以有机会动态地向类或者实例添加新的方法（避免崩溃），也即类的实现是可以动态绑定；isKindOfClass类似。</p></li><li><p>动态加载，主要是icon图片的加载会根据设备状态自动选取@2x @3x图片进行显示。</p></li></ul><h3 id="2、delegate、datasource-amp-block"><a href="#2、delegate、datasource-amp-block" class="headerlink" title="2、delegate、datasource&amp;block"></a>2、delegate、datasource&amp;block</h3><ul><li>delegate是委托回调，在OC中是一个类委托另一个类实现某个方法，一个对象会对他的delegate发送消息，执行delegate里的方法</li><li>datasource是数据源，主要和数据内容有关，一般为cell的属性和各种构造函数，是对数据源的处理。</li><li>block是简单的回调，相比delegate代码更加集中统一，写法更加简练，但要注意循环引用。在公共接口和方法较多情况下可以选择delegate，在异步回调（AFNetWorking…）或者简单的回调选择block，block涉及到栈内存和堆内存的拷贝，运行成本较大；而delegate只是一个对象指针的保存和回调。</li></ul><h3 id="3、让对象实现copy功能"><a href="#3、让对象实现copy功能" class="headerlink" title="3、让对象实现copy功能"></a>3、让对象实现copy功能</h3><p>实现copy功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying与 NSMutableCopying协议。<br>声明 NSCopying 协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;NSCopying&gt;</div></pre></td></tr></table></figure></p><p>实现 NSCopying 协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)copyWithZone:(NSZone *)zone;</div></pre></td></tr></table></figure></p><h3 id="4、深拷贝-amp-浅拷贝"><a href="#4、深拷贝-amp-浅拷贝" class="headerlink" title="4、深拷贝&amp;浅拷贝"></a>4、深拷贝&amp;浅拷贝</h3><ul><li><p>浅拷贝：指针拷贝，内存地址并未改变，只是将对象内存地址多了一个引用，在拷贝结束之后，两个对象的值不仅相同，而且对象所指的内存地址都是一样的。</p></li><li><p>深拷贝：内容拷贝，拷贝一个对象的具体内容，拷贝结束之后，两个对象的值虽然是相同的，但是指向的内存地址是不同的。两个对象之间也互不影响，互不干扰。</p></li><li><p>非集合类对象：对一个不可变对象进行copy操作，只仅仅是指针复制，进行mutableCopy操作，是内容复制；而对一个可变对象进行copy和mutableCopy操作，都是内容复制。</p></li></ul><p>-集合类对象：不可变对象copy相同，进行mutableCopy操作时，虽然数组内存地址发生了变化，但是数组元素的内存地址并没有发生变化（单层深拷贝）；对于可变对象，copy和mutableCopy都是内容复制，内存地址变化，但是数组元素的内存地址并没有发生变化（单层深拷贝）<br>集合类对象和非集合类对象的copy与mutablecopy</p><p>demo1:<br>NSString <em>origStr = @”123456”;<br>NSString </em>strCopy = [origStr copy];<br>NSMutableString *strMtCopy = [origStr mutablecopy];</p><p>demo2:<br>NSMutableStr <em>origStr = [NSMutableString stringWithFormat:@”123456”];<br>NSString </em>strCopy = [origStr copy];<br>NSMutableStr *strMuCopy = [origStr mutablecopy];</p><p>demo3:<br>NSArray <em>arr = @[@”a”, @”b”,@”c”];<br>NSArray </em>arrCopy = [array copy];<br>NSMutableArray *arrayMCopy = [array mutableCopy];</p><p>demo4:<br>NSMutableArray <em>arr =[ [NSMutableArray alloc] initWithObject:@”1”,@”2”,@”3”,nil];<br>NSArray </em>arrCopy = [array copy];<br>NSMutableArray *arrayMCopy = [array mutableCopy];</p><h3 id="5、进程-amp-线程-同步-amp-异步-并行-amp-串行"><a href="#5、进程-amp-线程-同步-amp-异步-并行-amp-串行" class="headerlink" title="5、进程&amp;线程 同步&amp;异步 并行&amp;串行"></a>5、进程&amp;线程 同步&amp;异步 并行&amp;串行</h3><p>1、进程是计算机操作系统分配资源的单位；线程是进程的基本执行单元，一个进程内的所有任务都在线程中执行；两者都是操作系统体积功的程序运行的基本单元，知识资源管理方式不同。进程有独立的地址空间，而线程只是一个进程中所执行的任务。线程有自己的堆栈空间和局部变量，没有单独的地址空间。一个进程内部可以有多个线程并发执行。<br>2、同步和异步是在线程单元中的概念。同步指在当前线程执行任务，不开启新的线程；异步指开启新的线程执行任务，不影响当前线程任务的执行。<br>3、并行与串行是线程内任务的执行方式。并行指多个任务同时执行，串行指按顺序执行，执行完一个任务后执行下一个（并发指处理多任务的能力，可以是多任务在同一时间段内执行，并不一定同时执行多个任务）。</p><h3 id="6、线程间通信"><a href="#6、线程间通信" class="headerlink" title="6、线程间通信"></a>6、线程间通信</h3><p>1、NSThread<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;</div><div class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait NS_AVAILABLE(10_5, 2_0);</div></pre></td></tr></table></figure></p><p>2、GCD<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">     </div><div class="line"> &#125;)</div><div class="line"> dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line"> </div><div class="line"> &#125;)</div></pre></td></tr></table></figure></p><p>GCD其他函数方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//延迟方法</div><div class="line"> dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(/*延迟时间*/  *NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">   &#125;</div><div class="line">//单例</div><div class="line">  static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">       //只执行一次的代码</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></p><p>3、NSOperation<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//创建线程队列</div><div class="line">NSOperstionQueue *queue =[[NSOperationQueue alloc] init];</div><div class="line">NSOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    //线程任务</div><div class="line">&#125;];</div><div class="line">[queue addOperation：operation];</div><div class="line">//获取main队列</div><div class="line">NSOperstionQueue *mainQueue = [NSOperationQueue mainQueue];</div><div class="line">[mainQueue addOperationWithBlock:^&#123;</div><div class="line">   //线程任务 </div><div class="line">&#125;];</div></pre></td></tr></table></figure></p><p> <a href="https://www.jianshu.com/p/6e6f4e005a0b" target="_blank" rel="external">多线程介绍可见这篇连接较详细</a></p><h3 id="7、iOS数据持久化"><a href="#7、iOS数据持久化" class="headerlink" title="7、iOS数据持久化"></a>7、iOS数据持久化</h3><ul><li>plist文件</li><li>Perference（UserDefaule）</li><li>NSKeyedArchiver（归档）：遵从NSCoding协议，实现解码和编码两个方法</li><li>SQLite3：使用三方库FMDB较为方便</li><li>CoreData</li></ul><h3 id="8、App生命周期"><a href="#8、App生命周期" class="headerlink" title="8、App生命周期"></a>8、App生命周期</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</div><div class="line">&#123;</div><div class="line">    // Override point for customization after application launch.</div><div class="line">    NSLog(@&quot;didFinishLaunchingWithOptions&quot;);</div><div class="line">    return YES;</div><div class="line">&#125;</div><div class="line">                            </div><div class="line">- (void)applicationWillResignActive:(UIApplication *)application</div><div class="line">&#123;</div><div class="line">    // Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.</div><div class="line">    // Use this method to pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. Games should use this method to pause the game.</div><div class="line">    NSLog(@&quot;WillResignActive&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)applicationDidEnterBackground:(UIApplication *)application</div><div class="line">&#123;</div><div class="line">    // Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later. </div><div class="line">    // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.</div><div class="line">    NSLog(@&quot;DidEnterBackground&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)applicationWillEnterForeground:(UIApplication *)application</div><div class="line">&#123;</div><div class="line">    // Called as part of the transition from the background to the inactive state; here you can undo many of the changes made on entering the background.</div><div class="line">    NSLog(@&quot;WillEnterForeground&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)applicationDidBecomeActive:(UIApplication *)application</div><div class="line">&#123;</div><div class="line">    // Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.</div><div class="line">    NSLog(@&quot;DidBecomeActive&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)applicationWillTerminate:(UIApplication *)application</div><div class="line">&#123;</div><div class="line">    // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.</div><div class="line">    NSLog(@&quot;WillTerminate&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>首次启动程序</strong><br>didFinishLaunchingWithOptions<br>DidBecomeActive<br><strong>从前台到后台</strong><br>WillResignActive<br>DidEnterBackground<br><strong>从后台到前台</strong><br>WillEnterForeground<br>DidBecomeActive</p><h3 id="9、NSCache-amp-NSDictionary"><a href="#9、NSCache-amp-NSDictionary" class="headerlink" title="9、NSCache&amp;NSDictionary"></a>9、NSCache&amp;NSDictionary</h3><p>两者基本用法相似。NSCache是线程安全的，可以指定缓存的限额，当缓存超出限额或者内存不足时NSCache会自动释放内存；NSMutableDictionary线程不安全。NScache相比功能更强大一些。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 缓存中总共可以存储多少条</div><div class="line">_cache.countLimit = 5;</div><div class="line">// 缓存的数据总量为多少</div><div class="line">_cache.totalCostLimit = 1024 * 5;</div><div class="line"></div><div class="line">//delegate</div><div class="line">//当缓存被移除的时候执行</div><div class="line">- (void)cache:(NSCache *)cache willEvictObject:(id)obj&#123;</div><div class="line">    NSLog(@&quot;缓存移除  %@&quot;,obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="10、description"><a href="#10、description" class="headerlink" title="10、description"></a>10、description</h3><p>description方法默认返回对象的描述信息(默认实现是返回类名和对象的内存地址)，重写description方法之后可以用来输出对象内部变量的值。调用NSLog(@”%@”, object);这会自动调用object的description方法来输出Object的描述信息.<br><strong>Attention：不要在description方法中同时使用%@和self，否则会陷入死循环，循环调用description方法</strong></p><h3 id="11、ARC"><a href="#11、ARC" class="headerlink" title="11、ARC"></a>11、ARC</h3><p>   ARC：Automatic Reference Counting 自动引用计数，苹果引入的一种内存管理机制。只要是为了解决MRC下手动创建和释放内存而造成的内存泄漏程序崩溃等问题。</p><h3 id="12、assign-VS-weak-；block-VS-weak"><a href="#12、assign-VS-weak-；block-VS-weak" class="headerlink" title="12、assign VS weak ；block VS weak"></a>12、assign VS weak ；<strong>block VS </strong>weak</h3><pre><code>assign用于修饰基础类型 float int 等等，weak用于修饰delegate block等对象类型，weak修饰的对象在对象废弃后会自动取消引用计数并置为nil，不会造成野指针；__block不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型。__block对象可以在block中被重新赋值，__weak不可以。__weak只能在ARC模式下使用，也只能修饰对象（NSString），不能修饰基本数据类型（int）。</code></pre><h3 id="13、KVC-KVO-NSNotifiction-delegate-block"><a href="#13、KVC-KVO-NSNotifiction-delegate-block" class="headerlink" title="13、KVC KVO NSNotifiction delegate block"></a>13、KVC KVO NSNotifiction delegate block</h3><pre><code>KVC: key value coding，根据key 的值访问属性KVO：观察者模式，对某个对象添加观察 实现oberserveValueForKeyPath：NSNotifiction：一对多的通知方式delegate：代理，一对一模式，将某些方法教给代理去执行block：delegate的灵活化方式，函数式编程的一种形式KVO一般的使用场景是数据，需求是数据变化，比如股票价格变化，我们一般使用KVO（观察者模式）。delegate一般的使用场景是行为，需求是需要别人帮我做一件事情，比如买卖股票，我们一般使用delegate。Notification一般是进行全局通知，比如利好消息一出，通知大家去买入。delegate是强关联，就是委托和代理双方互相知道，你委托别人买股票你就需要知道经纪人，经纪人也不要知道自己的顾客。Notification是弱关联，利好消息发出，你不需要知道是谁发的也可以做出相应的反应，同理发消息的人也不需要知道接收的人也可以正常发出消息。一般在block中修改变量都需要事先加__block进行修饰。在非arc中，__block修饰的变量的引用计算是不变的。在arc中，会引用到，并且计算+1；非arc下可使用（arc直接使用__weak即可）</code></pre><h3 id="14、MVC-vs-MVVM"><a href="#14、MVC-vs-MVVM" class="headerlink" title="14、MVC vs MVVM"></a>14、MVC vs MVVM</h3><pre><code>...</code></pre><h3 id="15、NSNumber-和-NSInteger"><a href="#15、NSNumber-和-NSInteger" class="headerlink" title="15、NSNumber 和 NSInteger"></a>15、NSNumber 和 NSInteger</h3><pre><code>NSNumber是类 ，而NSInteger是一个基本类型</code></pre><h3 id="16、如何重写类方法"><a href="#16、如何重写类方法" class="headerlink" title="16、如何重写类方法"></a>16、如何重写类方法</h3><pre><code>1、在子类中实现一个同基类名字一样的静态方法2、在调用的时候不要使用类名调用，而是使用[self class]的方式调用。原理，用类名调用是早绑定，在编译期绑定，用[self class]是晚绑定，在运行时决定调用哪个方法。</code></pre><h3 id="17、category-extension-继承"><a href="#17、category-extension-继承" class="headerlink" title="17、category/extension/继承"></a>17、category/extension/继承</h3><pre><code>category是在现有类的基础上添加新的方法，利用objective-c 的动态运行时分配机制，可以为现有类添加新方法。可以在分类中添加方法和成员变量，但是添加的成员变量不会自动生成setter和getter方法，需要在实现部分给出实现。extension就是匿名的分类，只有头文件没有实现文件。只能扩展方法，不能添加成员变量。扩展的方法只能在原类中实现。例如你扩展NSString,那么你只能在NSString的.m实现（这是不可能的），所以尽量少用扩展。用分类就可以了在iOS中继承是单继承，既只能有一个父类。在继承中，子类可以使用父类的方法和变量，当子类想对本类或者父类的变量进行初始化，那么需要重写init（）方法 。父类也可以访问子类的方法和成员变量。、</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Objective-C动态时特性&quot;&gt;&lt;a href=&quot;#1、Objective-C动态时特性&quot; class=&quot;headerlink&quot; title=&quot;1、Objective-C动态时特性&quot;&gt;&lt;/a&gt;1、Objective-C动态时特性&lt;/h3&gt;&lt;pre&gt;&lt;cod
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>UIWindow遇到的问题</title>
    <link href="https://yuweizhong.github.io/yu.github.io/2017/10/18/iOS%20%E9%81%87%E8%A7%81%E7%9A%84UIWindow%E9%97%AE%E9%A2%98/"/>
    <id>https://yuweizhong.github.io/yu.github.io/2017/10/18/iOS 遇见的UIWindow问题/</id>
    <published>2017-10-18T11:22:45.000Z</published>
    <updated>2018-01-03T11:29:50.978Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目里遇到了一个关于UIWindow的问题，便去查找了一下UIWIndow，故作此记录</p><p><strong>UIWindowLevel</strong><br>window层级主要有下面三类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UIKIT_EXTERN const UIWindowLevel UIWindowLevelNormal;</div><div class="line">UIKIT_EXTERN const UIWindowLevel UIWindowLevelAlert;</div><div class="line">UIKIT_EXTERN const UIWindowLevel UIWindowLevelStatusBar</div></pre></td></tr></table></figure></p><p><strong>keyWindow</strong></p><p>在ios 中用 [UIApplication sharedApplication].windows可以获取应用内所有设置的window：</p><h5 id="1-UIWIndow"><a href="#1-UIWIndow" class="headerlink" title="(1)UIWIndow"></a>(1)UIWIndow</h5><p>程序主要的keyWindow，程序展示的窗口</p><h5 id="2-UITextEffectsWindow"><a href="#2-UITextEffectsWindow" class="headerlink" title="(2)UITextEffectsWindow"></a>(2)UITextEffectsWindow</h5><p>这是iOS8引入的一个新window，是键盘所在的window。它的windowLevel是10，高于UIWindowLevelNormal。</p><h5 id="3-UIRemoteKeyboardWindow"><a href="#3-UIRemoteKeyboardWindow" class="headerlink" title="(3)UIRemoteKeyboardWindow"></a>(3)UIRemoteKeyboardWindow</h5><p>iOS9之后,新增了一个类型为 UIRemoteKeyboardWindow 的窗口用来显示键盘按钮。</p><p>当自定义添加window至页面上时（例如添加全局的悬浮窗口）每次弹窗 UIActionSheet或UIAlertView之后，再用[[UIApplication sharedApplication].keyWindow]获取keywindow时候，会取到最外层设置的UIWindow（项目中的全局悬浮窗口），就可能出现问题。</p><p>因为在打开UIActionSheet或UIAlertView弹窗时候，程序为了让弹框出现在最外层，会新建一个临时的UIWindow，并且层级最高，并设置为keywindow。在弹框消失后keywindow会自动变成下一层级的UIWindow（当前层级最高的UIwindow），即指向了项目中的全局悬浮窗口。 </p><p><strong>Add：使用iOS8后出现的UIAlertController不会出现上述问题</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近项目里遇到了一个关于UIWindow的问题，便去查找了一下UIWIndow，故作此记录&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UIWindowLevel&lt;/strong&gt;&lt;br&gt;window层级主要有下面三类&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;
      
    
    </summary>
    
    
      <category term="UIWindow" scheme="https://yuweizhong.github.io/yu.github.io/tags/UIWindow/"/>
    
  </entry>
  
  <entry>
    <title>iOS @property</title>
    <link href="https://yuweizhong.github.io/yu.github.io/2017/10/06/iOS%20@property/"/>
    <id>https://yuweizhong.github.io/yu.github.io/2017/10/06/iOS @property/</id>
    <published>2017-10-06T07:50:36.000Z</published>
    <updated>2018-01-10T12:26:26.512Z</updated>
    
    <content type="html"><![CDATA[<p>对于property，iOS开发者并不会陌生，无时无刻不在接触可是<strong>@property 的本质是什么？</strong></p><blockquote><p>@property = ivar + getter + setter;</p></blockquote><p>“属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）<br>“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为 Objective-C 2.0 的一部分。<br>property在runtime中是objc_property_t定义如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_property *objc_property_t;</div></pre></td></tr></table></figure></p><p>而objc_property是一个结构体，包括name和attributes，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct property_t &#123;</div><div class="line">     const char *name;</div><div class="line">     const char *attributes;</div><div class="line"> &#125;;</div></pre></td></tr></table></figure></p><p>而attributes本质是objc_property_attribute_t，定义了property的一些属性，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/// Defines a property attribute</div><div class="line">typedef struct &#123;</div><div class="line">    const char *name;           /**&lt; The name of the attribute */</div><div class="line">    const char *value;          /**&lt; The value of the attribute (usually empty) */</div><div class="line">&#125; objc_property_attribute_t;</div></pre></td></tr></table></figure></p><h4 id="property属性关键字"><a href="#property属性关键字" class="headerlink" title="@property属性关键字"></a>@property属性关键字</h4><ul><li><p>nonatomic —原子性<br>在默认情况下，由编译器合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用自旋锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的” ( atomic) )，但是仍然可以在属性特质中写明这一点，编译器不会报错。若是自己定义存取方法，那么就应该遵从与属性特质相符的原子性。</p></li><li><p>readwrite(读写)、readonly (只读) — 读/写权限</p></li><li><p>assign、strong、 weak、unsafe_unretained、copy — 内存管理语义</p></li></ul><ol><li>assign<br>简单赋值，不更改索引计数。 对基础数据类型 （例如NSInteger，CGFloat）和C数据类型（int, float, double, char, 等），适用简单数据类型。</li><li>strong(强引用)<br>ARC下的一个关键字。被强引用指向的内存不会被释放。强引用会对引用计数+1，从而拓展对象的生命周期。（retain调用的ARC版本）</li><li>weak弱引用：<br>弱引用是一种特殊的引用类型。它不会增加引用计数因而不会拓展对象的生命周期。当没有强引用指向对象时，弱引用会被置为nil。在对象回收时，weak具有安全性——指针将自动被设置为nil，避免野指针的出现</li><li>_unsafe_unretained:<br>与weak类似，只是没有强引用指向对象时，_unsafe_unretained不会被置为nil；</li><li>copy<br>建立一个索引计数为1的对象，然后释放旧对象。一般适用于存在可变对象的类型（例 NSString NSDictionary…）</li><li>atomic<br>atomic意为操作是原子的，意味着只有一个线程访问实例变量.属性的存取方法是线程安全的,很少使用，因为比较影响效率，性能比nonatomic差。</li><li>nonatomic<br>非原子的，可以被多个线程访问。它的效率比atomic快。禁止多线程，变量保护，提高性能，不能保证在多线程环境下的安全性，在单线程和明确只有一个线程访问的情况下广泛使用。<br>8.@synthesize 和 @dynamic<br>@property 有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize 和 @dynamic都没写，那么默认的就是 @syntheszie var = _var;<br>@synthesize ：如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@syntheszie var = _var;</div></pre></td></tr></table></figure></li></ol><p>@dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter 方法和 @getter 方法，编译的时候没问题，但是当程序运行到 instance.var = someVar，由于缺 setter 方法会导致程序崩溃；或者当运行到 someVar = var 时，由于缺 getter方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。</p><p><strong>A. 什么情况使用 weak 关键字，相比 assign 有什么不同？</strong></p><h5 id="什么情况使用-weak-关键字？"><a href="#什么情况使用-weak-关键字？" class="headerlink" title="什么情况使用 weak 关键字？"></a>什么情况使用 weak 关键字？</h5><p>在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性<br>自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong</p><h5 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h5><p>weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。 而 assign 的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或 NSlnteger 等)的简单赋值操作。</p><p>assign 可以用非 OC 对象,而 weak 必须用于 OC 对象</p><p><strong>B. 怎么用 copy 关键字？</strong></p><p>用途：</p><p>NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。<br>block 也经常使用 copy 关键字,block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在 ARC 中写不写都行；</p><p>copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。 当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。</p><p><strong>C.用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</strong></p><p>str1使用copy关键字 str2使用strong关键字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">-(void)test</div><div class="line">&#123;</div><div class="line">    NSMutableString*str=[NSMutableString stringWithFormat:@&quot;helloworld&quot;];</div><div class="line">    self.str1=str;</div><div class="line">    self.str2=str;</div><div class="line">    NSLog(@&quot;str:%p--%p&quot;,str,&amp;str);</div><div class="line">    NSLog(@&quot;copy_str:%p--%p&quot;,_str1,&amp;_str1);</div><div class="line">    NSLog(@&quot;strong_str:%p--%p&quot;,_str2,&amp;_str2);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2017-09-16 15:21:55.910 APP[1236:78490] str:0x600000075cc0--0x7fff5bd7c9d8</div><div class="line">2017-09-16 15:21:55.910 APP[1236:78490] copy_str:0x600000026e60--0x7fc66cc06358</div><div class="line">2017-09-16 15:21:55.911 APP[1236:78490] strong_str:0x600000075cc0--0x7fc66cc06360</div></pre></td></tr></table></figure><p>经过copy关键字修饰过的str1没有因为str的变化而变化，经过strong修饰过的str2却随str的改变而改变。对于希望字符串的值不跟着str变化，使用用copy来设置string的属性。如果希望字串的值跟着赋值的字串的值变化，可以使用strong。</p><p>**D.为什么不用assign修饰一个对象，而可以修饰基本数据类型？<br>assign修饰的对象（编译的时候会产生警告：Assigning retained object to unsafe property; object will be released after assignment）在释放之后，指针的地址还是存在的，并没有被置为nil，造成野指针。对象分配在堆上的某块内存，如果在后续的内存分配中，刚好分到了这块地址，程序就会crash。而基础数据类型是分配在栈上，栈的内存会由系统自己自动处理回收，不会造成野指针。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于property，iOS开发者并不会陌生，无时无刻不在接触可是&lt;strong&gt;@property 的本质是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;@property = ivar + getter + setter;&lt;/p&gt;
&lt;/blockqu
      
    
    </summary>
    
    
      <category term="iOS property copy weak strong" scheme="https://yuweizhong.github.io/yu.github.io/tags/iOS-property-copy-weak-strong/"/>
    
  </entry>
  
  <entry>
    <title>&#39;const&amp;static&amp;extern&#39;</title>
    <link href="https://yuweizhong.github.io/yu.github.io/2017/09/15/const&amp;static&amp;extern/"/>
    <id>https://yuweizhong.github.io/yu.github.io/2017/09/15/const&amp;static&amp;extern/</id>
    <published>2017-09-15T12:00:34.000Z</published>
    <updated>2017-12-27T12:22:56.464Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、const"><a href="#1、const" class="headerlink" title="1、const"></a>1、const</h3><p>用于常量修饰<br>    （1）const用来修饰右边的基本变量或指针变量<br>    （2）被修饰的变量只读，不能被修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int  const  *p   //  *p只读 ;p变量</div><div class="line"></div><div class="line">int  * const  p  // *p变量 ; p只读</div><div class="line"></div><div class="line"> const  int   * const p //p和*p都只读</div><div class="line"></div><div class="line"> int  const  * const  p   //p和*p都只读 </div><div class="line"></div><div class="line"> NSString * const myStr = @&quot;myStrStr&quot;; //声明字符串的用法</div></pre></td></tr></table></figure></p><h3 id="2、宏定义"><a href="#2、宏定义" class="headerlink" title="2、宏定义"></a>2、宏定义</h3><p>#define 预定义</p><blockquote><pre><code>在预处理时（编译前）进行文本替换，没有类型，不做任何类型检查能够定义一些函数方法等等，const做不到的大量的宏定义会导致编译时间长、二进制文件过大等等</code></pre></blockquote><h3 id="3、static"><a href="#3、static" class="headerlink" title="3、static"></a>3、static</h3><p>静态变量修饰</p><h4 id="修饰局部变量："><a href="#修饰局部变量：" class="headerlink" title="修饰局部变量："></a>修饰局部变量：</h4><blockquote><pre><code>1.延长局部变量的生命周期,程序结束才会销毁。2.局部变量只会生成一份内存,只会初始化一次。3.改变局部变量的作用域。</code></pre></blockquote><h4 id="修饰全局变量"><a href="#修饰全局变量" class="headerlink" title="修饰全局变量"></a>修饰全局变量</h4><blockquote><pre><code>1.只能在本文件中访问,修改全局变量的作用域,生命周期不会改2.避免重复定义全局变量</code></pre></blockquote><p>staic &amp;&amp; const联合使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 声明一个静态的全局只读常量（当前文件）</div><div class="line"> static NSString * const myStr = @&quot;myStrStr&quot;;</div></pre></td></tr></table></figure><h3 id="4、extern"><a href="#4、extern" class="headerlink" title="4、extern"></a>4、extern</h3><blockquote><pre><code>用来获取全局变量(包括全局静态变量)的值，不能用于定义变量，定义和分配内存都在原来类中。会在当前文件中先查找是否有改变量，其次再去全局查找</code></pre></blockquote><p>extern &amp;&amp; const联合使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//全局共享的变量</div><div class="line">A.h</div><div class="line">NSString * const myStr = @&quot;myStrStr&quot;;</div><div class="line">B.h</div><div class="line">extern NSString * const myStr;</div></pre></td></tr></table></figure><h3 id="5、UIKIT-EXTERN"><a href="#5、UIKIT-EXTERN" class="headerlink" title="5、UIKIT_EXTERN"></a>5、UIKIT_EXTERN</h3><p>如果多个.m文件需要用到同一个变量的情况，在pch文件中写上面这行代码,就相当于为每一个.m文件都写这行代码</p><pre><code>//例：苹果 系统预置的通知UIKIT_EXTERN NSString *const UIKeyboardWillShowNotification;UIKIT_EXTERN NSString *const UIKeyboardDidShowNotification;UIKIT_EXTERN NSString *const UIKeyboardWillHideNotification;UIKIT_EXTERN NSString *const UIKeyboardDidHideNotification;// UIKIT_EXTERN,是经过处理的extern</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、const&quot;&gt;&lt;a href=&quot;#1、const&quot; class=&quot;headerlink&quot; title=&quot;1、const&quot;&gt;&lt;/a&gt;1、const&lt;/h3&gt;&lt;p&gt;用于常量修饰&lt;br&gt;    （1）const用来修饰右边的基本变量或指针变量&lt;br&gt;    （2）被
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS加密和苹果证书</title>
    <link href="https://yuweizhong.github.io/yu.github.io/2017/09/02/iOS%E5%8A%A0%E5%AF%86%E5%92%8C%E8%8B%B9%E6%9E%9C%E8%AF%81%E4%B9%A6/"/>
    <id>https://yuweizhong.github.io/yu.github.io/2017/09/02/iOS加密和苹果证书/</id>
    <published>2017-09-02T11:16:52.000Z</published>
    <updated>2017-12-27T07:11:18.482Z</updated>
    
    <content type="html"><![CDATA[<h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><ul><li><p>base_64加密:最常见的用于传输8位字节代码的编码方式之一。更多的感觉Base_64是作为一个字符编码方式，而不是一个加密算法，用GTMBase64三方库</p></li><li><p>MD5加密:Message-Digest Algorithm 5，严格来说是一种摘要算法，MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值</p></li><li><p>DES加密:Data Encryption Standard：对称算法，数据加密标准，速度较快，适用于加密大量数据的场合；</p></li><li><p>HMAC加密算法：依赖于CommonCryptor库.主要应用于身份验证，为了防止匿名攻击，服务器需要确保每个请求都是从被信任的客户端发起的</p><h6 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h6><ol><li>客户端发出登录请求</li><li>服务器返回一个随机值（key），在会话记录中保存这个随机值</li><li>客户端将该随机值作为密钥，用户密码进行 hmac 运算，递交给服务器</li><li>服务器读取数据库中的用户密码，利用密钥做和客户端一样的hmac运算，然后与用户发送的结果比较，如果一致，则用户身份合法。</li></ol></li><li><p>RSA加密:非对称加密算法，加密的密钥和解密的秘钥不相同；</p><pre><code>公钥，可以对外给任何人的加密和解密密码，公开的，可以任何人访问私钥，私钥是一定要严格保护的，通过私钥可以生成公钥，但是从公钥可以认为是永远无法推导出私钥的</code></pre><h6 id="RSA加密主要包含-密钥生成算法、加密算法和解密算法三部"><a href="#RSA加密主要包含-密钥生成算法、加密算法和解密算法三部" class="headerlink" title="RSA加密主要包含 密钥生成算法、加密算法和解密算法三部"></a>RSA加密主要包含 密钥生成算法、加密算法和解密算法三部</h6><pre><code>1.  通过密钥生成算法生成公钥(Public Key)和私钥(Primary Key)，公钥一般公开给客户端，私钥由服务器保留2.  客户端通过公钥进行加密，传给服务端3.  服务端收到客户端数据包之后用私钥解密得到对应数据</code></pre><h6 id="RSA签名（认证）主要包含-密钥生成算法、签名算法和验证算法"><a href="#RSA签名（认证）主要包含-密钥生成算法、签名算法和验证算法" class="headerlink" title="RSA签名（认证）主要包含 密钥生成算法、签名算法和验证算法"></a>RSA签名（认证）主要包含 密钥生成算法、签名算法和验证算法</h6><pre><code>1.  通RSA加密相同的生成公钥(Public Key)和私钥(Primary Key)2.  通过私钥和数据包（一般为文件）进行加密,实现对文件的签名3.  将数据包（文件）通过公钥解密，验证签名</code></pre></li></ul><hr><h3 id="苹果证书"><a href="#苹果证书" class="headerlink" title="苹果证书"></a>苹果证书</h3><h4 id="证书类型"><a href="#证书类型" class="headerlink" title="证书类型"></a>证书类型</h4><ul><li style="list-style: none"><input type="checkbox"> 开发证书:一般为99证书，开发真机调试用</li><li style="list-style: none"><input type="checkbox"> 发布证书：app发布到appstore时候打包使用</li><li style="list-style: none"><input type="checkbox"> 推送证书：ConnectCenter创建推送证书，注册推送功能</li><li style="list-style: none"><input type="checkbox"> 企业证书：299证书，不需要发布到appstore，打包信任后即可安装</li></ul><h4 id="证书申请使用"><a href="#证书申请使用" class="headerlink" title="证书申请使用"></a>证书申请使用</h4><ol><li>开发者使用Mac电脑像CA机构创建证书申请，本地会生成csr文件，同时秘钥保存在本地（后续打发布的包用于Xcode验证）</li><li>开发者在ConnectCenter上传csr文件申请证书，并下载到本地，双击打开后从钥匙串生成.p12文件可用于其他设备打包发布</li><li>生成成provisioning profile时选择对应的证书，然后下载安装相应的provisioning文件（称描述文件），描述文件包含公钥、设备信息、开发者信息、过期信息等等；</li><li>在程序打包时，会用私钥就代码进行加密，然后把provisioning文件包含到app文件中。当iOS设备安装应用时，首先用CA的公钥解密出开发者的公钥，然后再用开发者的公钥解密出代码，完成安装</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;加密算法&quot;&gt;&lt;a href=&quot;#加密算法&quot; class=&quot;headerlink&quot; title=&quot;加密算法&quot;&gt;&lt;/a&gt;加密算法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;base_64加密:最常见的用于传输8位字节代码的编码方式之一。更多的感觉Base_64是作为一个字符编码
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS开发之状态栏导航栏</title>
    <link href="https://yuweizhong.github.io/yu.github.io/2017/08/26/iOS%E5%BC%80%E5%8F%91%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A0%8F%E5%AF%BC%E8%88%AA%E6%A0%8F/"/>
    <id>https://yuweizhong.github.io/yu.github.io/2017/08/26/iOS开发之状态栏导航栏/</id>
    <published>2017-08-26T10:41:44.000Z</published>
    <updated>2017-08-31T10:50:56.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS开发之状态栏导航栏"><a href="#iOS开发之状态栏导航栏" class="headerlink" title="iOS开发之状态栏导航栏"></a><strong>iOS开发之状态栏导航栏</strong></h1><hr><h1 id="​状态栏"><a href="#​状态栏" class="headerlink" title="​状态栏"></a><code>​</code>状态栏</h1><h2 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h2><p>将info.plist文件的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Viewcontroller-based status bar ppearance</div></pre></td></tr></table></figure></p><p>设置为NO，即可开启全局设置，也就是说你在VC中对状态栏的控制都将无效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//设置状态栏的字体颜色模式</div><div class="line">&gt; [[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent];</div><div class="line">//设置状态栏是否隐藏</div><div class="line">[[UIApplication sharedApplication] setStatusBarHidden:YES];</div><div class="line">UIStatusBarStyleDefault和UIStatusBarStyleLightContent，前者是默认的黑色，而后者是白色。</div></pre></td></tr></table></figure></p><h2 id="分页面设置"><a href="#分页面设置" class="headerlink" title="分页面设置"></a>分页面设置</h2><p>将info.plist文件的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Viewcontroller-based status bar ppearance</div></pre></td></tr></table></figure></p><p>设置为YES，即可开启由VC来控制状态栏的功能，在这种模式下，全局的设置将无效！！所以我们必须逐个页面对状态栏进行设置，否则状态栏将维持默认的黑色字体和默认为显示状态。<br>1) 当VC不在UINavigationController中时，在VC中添加一个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (UIStatusBarStyle)preferredStatusBarStyle</div><div class="line">&#123;</div><div class="line"> //返回白色</div><div class="line"> return UIStatusBarStyleLightContent;</div><div class="line"> //返回黑色</div><div class="line"> //return UIStatusBarStyleDefault;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>保险起见，在view的某个加载阶段比如viewWillAppear中，执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self setNeedsStatusBarAppearanceUpdate];</div></pre></td></tr></table></figure></p><p>2) 当VC在UINavigationController中时，VC并不能通过1)的方式控制状态栏的颜色，详见本文后面的参考资料，那么这个时候，有一个trick的方法可以在VC中间接的控制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.navigationController.navigationBar.barStyle = UIBarStyleBlack;</div></pre></td></tr></table></figure></p><h1 id="导航栏"><a href="#导航栏" class="headerlink" title="##导航栏"></a>##导航栏</h1><p>导航栏背景控制 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[UINavigationBar appearance] setBarTintColor:[UIColor yellowColor]];</div></pre></td></tr></table></figure></p><p>导航栏背景图片 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[UINavigationBar appearance] setBackgroundImage:[UIImage imageNamed:@ &quot;nav_bg.png&quot; ]  forBarMetrics:UIBarMetricsDefault]; （图片64px覆盖状态栏）</div></pre></td></tr></table></figure><p>导航栏标题设置 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSShadow *shadow = [[NSShadow alloc] init]; </div><div class="line"> shadow.shadowColor = [UIColor colorWithRed:0.0 green:0.0 blue:0.0 alpha:0.8]; </div><div class="line"> shadow.shadowOffset = CGSizeMake(0, 1); </div><div class="line"> [[UINavigationBar appearance] setTitleTextAttributes: [NSDictionary dictionaryWithObjectsAndKeys: </div><div class="line"> [UIColor colorWithRed:245.0/255.0 green:245.0/255.0 blue:245.0/255.0 alpha:1.0], NSForegroundColorAttributeName, </div><div class="line"> shadow, NSShadowAttributeName, </div><div class="line"> [UIFont fontWithName:@ &quot;HelveticaNeue-CondensedBlack&quot; size:21.0], NSFontAttributeName, nil]];</div></pre></td></tr></table></figure></p><p>导航栏按钮颜色设置 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[UINavigationBar appearance] setTintColor:[UIColor whiteColor]];</div></pre></td></tr></table></figure></p><p>导航栏下控件定位 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">self.automaticallyAdjustsScrollViewInsets =NO;（scrollView布局设置）</div><div class="line">if (on) &#123; (控件自动下移64)</div><div class="line"></div><div class="line"> self.edgesForExtendedLayout = UIRectEdgeNone;</div><div class="line"></div><div class="line"> &#125;else&#123;</div><div class="line"></div><div class="line"> self.edgesForExtendedLayout = UIRectEdgeAll;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>导航栏图标左移<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//创建UIBarButtonSystemItemFixedSpace</div><div class="line">UIBarButtonItem * spaceItem = [[UIBarButtonItem alloc]initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace target:nil action:nil];</div><div class="line">//将宽度设为负值</div><div class="line">spaceItem.width = -15;</div><div class="line">//将两个BarButtonItem都返回给NavigationItem</div><div class="line">self.navigationItem.leftBarButtonItems = @[spaceItem,leftBarBtn];</div></pre></td></tr></table></figure></p><p>全屏滑动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">id target = self.interactivePopGestureRecognizer.delegate;</div><div class="line">// 创建全屏滑动手势，调用系统自带滑动手势的target的action方法</div><div class="line"> UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:target action:@selector(handleNavigationTransition:)];</div><div class="line"> // 设置手势代理，拦截手势触发</div><div class="line">pan.delegate = self;</div><div class="line">// 给导航控制器的view添加全屏滑动手势</div><div class="line">  [self.view addGestureRecognizer:pan];</div><div class="line"> // 禁止使用系统自带的滑动手势</div><div class="line">self.interactivePopGestureRecognizer.enabled = NO;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS开发之状态栏导航栏&quot;&gt;&lt;a href=&quot;#iOS开发之状态栏导航栏&quot; class=&quot;headerlink&quot; title=&quot;iOS开发之状态栏导航栏&quot;&gt;&lt;/a&gt;&lt;strong&gt;iOS开发之状态栏导航栏&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;​状态
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>First Blog</title>
    <link href="https://yuweizhong.github.io/yu.github.io/2017/08/21/FirstBlog/"/>
    <id>https://yuweizhong.github.io/yu.github.io/2017/08/21/FirstBlog/</id>
    <published>2017-08-21T10:42:06.000Z</published>
    <updated>2017-08-21T11:58:22.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo-GitHub"><a href="#hexo-GitHub" class="headerlink" title="hexo+GitHub"></a><strong>hexo+GitHub</strong></h1><p> 很早就有写博客这个想法，希望有一个个人的独立博客，最后采用了hexo+github的方式建立了这个个人博客。</p><h2 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h2><p>hexo是一款基于Node.js的静态博客框架，和jekyll相似，鉴于hexo以下优点，最后，使用了hexo作为博客框架</p><ol><li>依赖少（仅依赖node），易于安装</li><li>台湾人写的，不用担心对中文支持不好</li><li>对程序员友好，要是愿意折腾还是有的折腾的</li></ol><h2 id="构建博客步骤"><a href="#构建博客步骤" class="headerlink" title="构建博客步骤"></a>构建博客步骤</h2><ul><li>安装Git Bash</li><li>安装node.js<br>++（傻瓜式安装不多做解释）++</li><li>创建文件夹作仓库（例如blog目录）进入到该目录 </li><li>安装hexo： npm i -g hexo </li><li>初始化：hexo init<h3 id="生成目录"><a href="#生成目录" class="headerlink" title="生成目录"></a>生成目录</h3></li><li style="list-style: none"><input type="checkbox"> node_modules：是依赖包</li><li style="list-style: none"><input type="checkbox"> public：存放的是生成的页面</li><li style="list-style: none"><input type="checkbox"> scaffolds：命令生成文章等的模板</li><li style="list-style: none"><input type="checkbox"> source：用命令创建的各种文章</li><li style="list-style: none"><input type="checkbox"> themes：主题</li><li style="list-style: none"><input type="checkbox"> _config.yml：整个博客的配置</li><li style="list-style: none"><input type="checkbox"> db.json：source解析所得到的</li><li style="list-style: none"><input type="checkbox"> package.json：项目所需模块项目的配置信息</li></ul><h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><ul><li>注册github账号（已注册的忽略）</li><li>创建一个repo，名称为yourname.github.io, 其中yourname是你的github名称 </li><li>创建完之后，用编辑器打开你的blog项目，修改_config.yml文件最后的一些配置(冒号之后都是有一个半角空格的)<br>deploy:<br>type: git<br>repo: <a href="https://github.com/YourgithubName/YourgithubName.github.io.git" target="_blank" rel="external">https://github.com/YourgithubName/YourgithubName.github.io.git</a><br>branch: master</li><li>回到gitbash中，进入你的blog目录，分别执行以下命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo clean</div><div class="line">hexo generate</div><div class="line">hexo server</div></pre></td></tr></table></figure></li></ul><p>打开浏览器输入：<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 可以查看到博客主页</p><h2 id="上传github"><a href="#上传github" class="headerlink" title="上传github"></a>上传github</h2><ul><li><p>先安装一波：npm install hexo-deployer-git–save（这样才能将你写好的文章部署到github服务器上并让别人浏览到）</p></li><li><p>执行命令(建议每次都按照如下步骤部署)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo clean</div><div class="line">hexo generate</div><div class="line">hexo deploy</div></pre></td></tr></table></figure></li></ul><p>在浏览器中输入 <a href="http://yourgithubname.github.io" target="_blank" rel="external">http://yourgithubname.github.io</a> 就可以看到你的个人博客啦</p><h3 id="修改博客主页主题"><a href="#修改博客主页主题" class="headerlink" title="修改博客主页主题"></a>修改博客主页主题</h3><p>网址<a href="https://hexo.io/themes/" target="_blank" rel="external">https://hexo.io/themes/</a><br>github上clone到themes里面更改config配置后即可生效</p><h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo new &apos;文章名&apos;</div></pre></td></tr></table></figure><p>然后你就可以在source/_posts路径下看到你创建的文章啦，编辑完成之后按照前面说的方式部署，在浏览器刷新就能看到你的文章了。至于markdown，可以自行发挥！！！</p><hr><p>可以说，2017年是特殊的一年，从学校步入到了社会，在近两年iOS形势大败之下能够成功入职了某大型互联网金融公司，现在看来也是不错的。当然，在仔细品味大神的博客之后，对博客也萌生了更多的想法，在这后博客时代，博客是一个单纯美好的平台，一个分享、记录的平台。动笔写博客主要是想能够充实自己</p><ol><li>积累==积累一些实在的东西，踏实的继续走下去</li><li>坚持==坚持撰写博客，不断激励自己，不断进步</li><li>分享==分享一些自己学习到的技术和知识</li><li>记录==记录技术道路上的点滴<h4 id="我的博客诞生于2017年，伴随着第一份正式工作的尘埃落定。希望接下来能够坚持这个习惯，能够不断充实自己！！！"><a href="#我的博客诞生于2017年，伴随着第一份正式工作的尘埃落定。希望接下来能够坚持这个习惯，能够不断充实自己！！！" class="headerlink" title="我的博客诞生于2017年，伴随着第一份正式工作的尘埃落定。希望接下来能够坚持这个习惯，能够不断充实自己！！！"></a>我的博客诞生于2017年，伴随着第一份正式工作的尘埃落定。希望接下来能够坚持这个习惯，能够不断充实自己！！！</h4></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;hexo-GitHub&quot;&gt;&lt;a href=&quot;#hexo-GitHub&quot; class=&quot;headerlink&quot; title=&quot;hexo+GitHub&quot;&gt;&lt;/a&gt;&lt;strong&gt;hexo+GitHub&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt; 很早就有写博客这个想法，希望有一
      
    
    </summary>
    
    
  </entry>
  
</feed>
