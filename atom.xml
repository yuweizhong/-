<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YuWeizhong</title>
  
  <subtitle>Hope Future , Do Now!!!</subtitle>
  <link href="/yu.github.io/atom.xml" rel="self"/>
  
  <link href="https://yuweizhong.github.io/yu.github.io/"/>
  <updated>2018-09-18T08:57:10.616Z</updated>
  <id>https://yuweizhong.github.io/yu.github.io/</id>
  
  <author>
    <name>YuWeizhong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS下并行串行&amp;&amp;同步异步</title>
    <link href="https://yuweizhong.github.io/yu.github.io/2018/09/18/%E5%B9%B6%E8%A1%8C%E4%B8%B2%E8%A1%8C&amp;&amp;%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5/"/>
    <id>https://yuweizhong.github.io/yu.github.io/2018/09/18/并行串行&amp;&amp;同步异步/</id>
    <published>2018-09-18T08:52:31.000Z</published>
    <updated>2018-09-18T08:57:10.616Z</updated>
    
    <content type="html"><![CDATA[<p>首先，先来理解几个基础名词概念：</p><blockquote><p>进程:正在进行中的程序被称为进程，负责程序运行的内存分配;每一个进程都有自己独立的虚拟内存空间</p><p>线程:线程是进程中一个独立的执行路径(控制单元);一个进程中至少包含一条线程，即主线程，线程里面有非常多的任务（同步，异步）</p><p>任务：任务的执行分为同步和异步，任务是在线程中执行的</p><p>多线程: 并不是所有的框架都支持多线程, 必须要有多核的cpu支持才行, 单核cpu即使开了多线程运行速度也不会有变化，过多的线程会占用大量的内存</p></blockquote><h2 id="同步、异步："><a href="#同步、异步：" class="headerlink" title="同步、异步："></a>同步、异步：</h2><p>指的是能否开启新的线程。同步不能开启新的线程，异步可以。</p><h2 id="串行、并行："><a href="#串行、并行：" class="headerlink" title="串行、并行："></a>串行、并行：</h2><p>指的是任务的执行方式。串行是指多个任务时，各个任务按顺序执行，完成一个之后才能进行下一个。并行指的是多个任务可以同时执行。异步是多个任务并行的前提条件。</p><p>接下来，用GCD来作测试…<br>GCD下的队列有两种:串行队列和并发队列，区别主要在于是否创建多个线程。</p><h3 id="串行队列同步执行"><a href="#串行队列同步执行" class="headerlink" title="串行队列同步执行"></a>串行队列同步执行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;serialQueue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">    dispatch_sync(queue, ^&#123;</div><div class="line">        NSLog(@&quot;task1&quot;);</div><div class="line">        NSLog(@&quot;task1---%@&quot;,[NSThread currentThread]);</div><div class="line">    &#125;);</div><div class="line">     </div><div class="line">    dispatch_sync(queue, ^&#123;</div><div class="line">        NSLog(@&quot;task2&quot;);</div><div class="line">        NSLog(@&quot;task2---%@&quot;,[NSThread currentThread]);</div><div class="line">    &#125;);</div><div class="line">     </div><div class="line">    dispatch_sync(queue, ^&#123;</div><div class="line">        NSLog(@&quot;task3&quot;);</div><div class="line">        NSLog(@&quot;task3---%@&quot;,[NSThread currentThread]);</div><div class="line">    &#125;);</div></pre></td></tr></table></figure><h3 id="串行队列异步执行"><a href="#串行队列异步执行" class="headerlink" title="串行队列异步执行"></a>串行队列异步执行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">[NSThread detachNewThreadSelector:@selector(threadAction) toTarget:self withObject:nil];</div><div class="line"></div><div class="line">-(void)threadAction&#123;</div><div class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;serialQueue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">    dispatch_sync(queue, ^&#123;</div><div class="line">        NSLog(@&quot;task1&quot;);</div><div class="line">        NSLog(@&quot;task1---%@&quot;,[NSThread currentThread]);</div><div class="line">    &#125;);</div><div class="line">     </div><div class="line">    dispatch_sync(queue, ^&#123;</div><div class="line">        NSLog(@&quot;task2&quot;);</div><div class="line">        NSLog(@&quot;task2---%@&quot;,[NSThread currentThread]);</div><div class="line">    &#125;);</div><div class="line">     </div><div class="line">    dispatch_sync(queue, ^&#123;</div><div class="line">        NSLog(@&quot;task3&quot;);</div><div class="line">        NSLog(@&quot;task3---%@&quot;,[NSThread currentThread]);</div><div class="line">    &#125;);</div><div class="line">     </div><div class="line">    NSLog(@&quot;task4&quot;);</div><div class="line">    NSLog(@&quot;task4---%@&quot;,[NSThread currentThread]);</div><div class="line">&#125;·</div></pre></td></tr></table></figure><h3 id="并行队列同步执行"><a href="#并行队列同步执行" class="headerlink" title="并行队列同步执行"></a>并行队列同步执行</h3><pre><code>同串行队列同步执行</code></pre><h3 id="并行队列异步执行"><a href="#并行队列异步执行" class="headerlink" title="并行队列异步执行"></a>并行队列异步执行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;concurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    dispatch_async(queue, ^&#123;</div><div class="line">        NSLog(@&quot;task1&quot;);</div><div class="line">        NSLog(@&quot;task1---%@&quot;,[NSThread currentThread]);</div><div class="line">    &#125;);</div><div class="line">     </div><div class="line">    dispatch_async(queue, ^&#123;</div><div class="line">        NSLog(@&quot;task2&quot;);</div><div class="line">        NSLog(@&quot;task2---%@&quot;,[NSThread currentThread]);</div><div class="line">    &#125;);</div><div class="line">     </div><div class="line">    dispatch_async(queue, ^&#123;</div><div class="line">        NSLog(@&quot;task3&quot;);</div><div class="line">        NSLog(@&quot;task3---%@&quot;,[NSThread currentThread]);</div><div class="line">    &#125;);</div><div class="line">     </div><div class="line">    NSLog(@&quot;task4&quot;);</div><div class="line">    NSLog(@&quot;task4---%@&quot;,[NSThread currentThread]);</div></pre></td></tr></table></figure><p> 1.串行队列,每次只执行一个任务，无论用什么方式加入任务。</p><p>  //为了清楚表示可以写为DISPATCH_QUEUE_SERIAL，iOS官方文档定义的DISPATCH_QUEUE_SERIAL就是NULL</p><p> 使用串行队列，任务都是挨个执行，每次只运行一个。</p><p>  dispatch_queue_t serialQueue=dispatch_queue_create(“串行队列”, NULL);</p><p>  dispatch_sync(serialQueue, ^(){</p><pre><code>    NSLog(@“同步加入任务－－－－－－－%@“,[NSThread currentThread]);});dispatch_async(serialQueue, ^(){    NSLog(@“异步加入任务——%@“,[NSThread currentThread]);   });</code></pre><p>2.并行队列,每次执行多个任务</p><p>dispatch_queue_t concurrentQueue = dispatch_queue_create(“并行队列”, DISPATCH_QUEUE_CONCURRENT);</p><p> dispatch_sync(concurrentQueue, ^(){</p><pre><code>    NSLog(@“同步加入任务－－－－－－－%@“,[NSThread currentThread]);});dispatch_async(concurrentQueue, ^(){    NSLog(@“异步加入任务——%@“,[NSThread currentThread]);   });</code></pre><p>3.用Dispatch Groups实现判断多线程全部执行结束</p><pre><code>// 获取全局队列，全局队列是系统提供的并行队列dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_group_t group = dispatch_group_create();// 添加队列到组中dispatch_group_async(group, queue, ^{    NSLog(@&quot;11111111111&quot;);});dispatch_group_async(group, queue, ^{    NSLog(@&quot;22222222222&quot;);});dispatch_group_async(group, queue, ^{     NSLog(@&quot;33333333&quot;);});dispatch_group_notify(group, dispatch_get_main_queue(), ^{     NSLog(@“以上执行完成后才执行这里！！！”);});</code></pre><p>  也可以使用dispatch_group_wait来完成此功能，但是他会阻塞当前线程</p><p>4.只执行某个函数一次</p><p>  static dispatch_once_t onceToken;</p><pre><code>for(int i=0;i&lt;5;i++){dispatch_once(&amp;onceToken, ^{    NSLog(@&quot;only once&quot;);    });}</code></pre><p>5.信号量</p><pre><code>dispatch_queue_t queue = dispatch_get_global_queue(0, 0);dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);for (int index = 0; index &lt; 10; index++) {    dispatch_async(queue, ^(){       dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);        NSLog(@“信号量资源就一个，按顺序执行 :%d&quot;, index);        if(index==5)        {         [NSThread sleepForTimeInterval:3];             }      dispatch_semaphore_signal(semaphore);     });}</code></pre><p>6.队列的挂起、恢复</p><p>dispatch_queue_t myQueue;</p><p>myQueue = dispatch_queue_create(“队列”, NULL);</p><p>//挂起队列</p><p>  dispatch_sync(myQueue, ^(){</p><pre><code>    NSLog(@“挂起任务之前“);});</code></pre><p>dispatch_suspend(myQueue);</p><p>dispatch_sync(myQueue, ^(){</p><pre><code>    NSLog(@“挂起任务之后“);});</code></pre><p>//恢复队列</p><p>dispatch_resume(myQueue);</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先，先来理解几个基础名词概念：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;进程:正在进行中的程序被称为进程，负责程序运行的内存分配;每一个进程都有自己独立的虚拟内存空间&lt;/p&gt;
&lt;p&gt;线程:线程是进程中一个独立的执行路径(控制单元);一个进程中至少包含一条线程，即主线程，线
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Toll-Free Bridged</title>
    <link href="https://yuweizhong.github.io/yu.github.io/2018/09/06/Toll-Free-Bridged/"/>
    <id>https://yuweizhong.github.io/yu.github.io/2018/09/06/Toll-Free-Bridged/</id>
    <published>2018-09-06T06:43:41.000Z</published>
    <updated>2018-09-06T06:44:13.485Z</updated>
    
    <content type="html"><![CDATA[<p>穿插一个小的知识点 介绍一下Toll-free bridged</p><blockquote><p> Toll-free bridging,简称为TFB，是一种允许某些ObjC类与其对应的CoreFoundation类之间可以互换使用的机制。比如 NSString与CFString是桥接(bridged)的, 这意味着可以将任意NSString当做CFString使用，也可以将任意的CFString当做NSString使用。</p></blockquote><p>那么既然有了NSString 为什么还需要CFString 的存在呢？<br><a href="https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFDesignConcepts/Articles/tollFreeBridgedTypes.html#/apple_ref/doc/uid/TP40010677" target="_blank" rel="external">官网</a>解释：</p><blockquote><p>CFString provides a suite of efficient string-manipulation and string-conversion functions. It offers seamless Unicode support and facilitates the sharing of data between Cocoa and C-based programs</p></blockquote><p> 翻译</p><blockquote><p>CFString提供了一套高效的字符串操作和字符串转换功能。 它提供无缝的Unicode支持，并促进Cocoa和基于C的程序之间的数据共享。</p></blockquote><h2 id="Toll-Free-Bridged-Types"><a href="#Toll-Free-Bridged-Types" class="headerlink" title="Toll-Free Bridged Types"></a>Toll-Free Bridged Types</h2><p><img src="https://raw.githubusercontent.com/yuweizhong/Resources/master/Img/tfb.png" alt="TFB"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;穿插一个小的知识点 介绍一下Toll-free bridged&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; Toll-free bridging,简称为TFB，是一种允许某些ObjC类与其对应的CoreFoundation类之间可以互换使用的机制。比如 NSString与CF
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RunTime</title>
    <link href="https://yuweizhong.github.io/yu.github.io/2018/09/04/RunTime/"/>
    <id>https://yuweizhong.github.io/yu.github.io/2018/09/04/RunTime/</id>
    <published>2018-09-04T03:13:41.000Z</published>
    <updated>2018-09-04T03:15:30.827Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RunTime"><a href="#RunTime" class="headerlink" title="RunTime"></a>RunTime</h1><p>RunTime，简称运行时，是用C和汇编编写的一套底层API，是Objective-C面向对象和动态机制的基础。<br><a href="https://opensource.apple.com/source/objc4/" target="_blank" rel="external">开放源码地址</a></p><p><a href="https://developer.apple.com/documentation/objectivec/objective_c_runtime#//apple_ref/doc/uid/TP40001418-CH1g-126286" target="_blank" rel="external">API地址</a></p><h2 id="1-类实例（objc-object"><a href="#1-类实例（objc-object" class="headerlink" title="1.类实例（objc_object)"></a>1.类实例（objc_object)</h2><p>objc_object结构体定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct objc_object &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/// A pointer to an instance of a class.</div><div class="line">typedef struct objc_object *id;</div></pre></td></tr></table></figure><p>类实例的isa指针指向其所在类对象</p><h2 id="2-类对象（objc-class）"><a href="#2-类对象（objc-class）" class="headerlink" title="2.类对象（objc_class）"></a>2.类对象（objc_class）</h2><p>objc_class结构体定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_class *Class;</div><div class="line"></div><div class="line">struct objc_class &#123;</div><div class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</div><div class="line"></div><div class="line">#if !__OBJC2__</div><div class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;     //父类指针</div><div class="line">    const char * _Nonnull name                               OBJC2_UNAVAILABLE;     //类名字</div><div class="line">    long version                                             OBJC2_UNAVAILABLE;     //版本</div><div class="line">    long info                                                OBJC2_UNAVAILABLE;     //信息</div><div class="line">    long instance_size                                       OBJC2_UNAVAILABLE;     //实例大小</div><div class="line">    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;     //变量列表</div><div class="line">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE; //方法列表</div><div class="line">    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;     //缓存</div><div class="line">    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;     //遵守的协议列表</div><div class="line">#endif</div><div class="line"></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure></p><p>struct objc_class结构体定义了很多变量（标注如上），类对象就是一个结构体struct objc_class，这个结构体存放的数据称为元数据(metadata)，<br>对象中的元数据存储的都是如何创建一个实例的相关信息，那么类对象和类方法应该从哪里创建呢？<br>就是从isa指针指向的结构体创建，类对象的isa指针指向的我们称之为元类(metaclass)，元类中保存了创建类对象以及类方法所需的所有信息。</p><h2 id="3-元类（Meta-Class）"><a href="#3-元类（Meta-Class）" class="headerlink" title="3.元类（Meta Class）"></a>3.元类（Meta Class）</h2><p>元类(Meta Class)是一个类对象的类。所有的类自身也是一个对象，我们可以向这个对象发送消息(即调用类方法)。<br>为了调用类方法，这个类的isa指针必须指向一个包含这些类方法的一个objc_class结构体。这就引出了meta-class的概念，元类中保存了创建类对象以及类方法所需的所有信息。<br>任何NSObject继承体系下的meta-class都使用NSObject的meta-class作为自己的所属类，而基类的meta-class的isa指针是指向它自己。</p><p>类实例，类对象和元类的整个结构图所示:<br><img src="http://note.youdao.com/favicon.ico" alt="image"><br>通过上图我们可以看出整个体系构成了一个自闭环，struct objc_object结构体实例它的isa指针指向类对象，<br>类对象的isa指针指向了元类，super_class指针指向了父类的类对象，<br>而元类的super_class指针指向了父类的元类，那元类的isa指针又指向了自己。</p><h2 id="4-Method-objc-method"><a href="#4-Method-objc-method" class="headerlink" title="4.Method(objc_method)"></a>4.Method(objc_method)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">runtime.h</div><div class="line">/// An opaque type that represents a method in a class definition.代表类定义中一个方法的不透明类型</div><div class="line">typedef struct objc_method *Method;</div><div class="line">struct objc_method &#123;</div><div class="line">    SEL method_name                  OBJC2_UNAVAILABLE;  //方法名</div><div class="line">    char *method_types               OBJC2_UNAVAILABLE;  //方法类型</div><div class="line">    IMP method_imp                   OBJC2_UNAVAILABLE;  //方法实现</div></pre></td></tr></table></figure><pre><code>其中 SEL和IMP其实都是Method的属性。</code></pre><h3 id="SEL-object-selector"><a href="#SEL-object-selector" class="headerlink" title="SEL(object_selector)"></a>SEL(object_selector)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Objc.h</div><div class="line">/// An opaque type that represents a method selector.代表一个方法的不透明类型</div><div class="line">typedef struct objc_selector *SEL;</div></pre></td></tr></table></figure><p>selector是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是SEL,selector是SEL的一个实例.</p><blockquote><p>同一个类，selector不能重复<br>不同的类，selector可以重复</p></blockquote><h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/// A pointer to the function of a method implementation.  指向一个方法实现的指针</div><div class="line">typedef id (*IMP)(id, SEL, ...); </div><div class="line">#endif</div></pre></td></tr></table></figure><p>指向最终实现程序的内存地址的指针</p><h2 id="类缓存（object-cache"><a href="#类缓存（object-cache" class="headerlink" title="类缓存（object_cache)"></a>类缓存（object_cache)</h2><p>当Objective-C运行时通过跟踪它的isa指针检查对象时，它可以找到一个实现许多方法的对象。然而，你可能只调用它们的一小部分，并且每次查找时，搜索所有选择器的类分派表没有意义。所以类实现一个缓存，每当你搜索一个类分派表，并找到相应的选择器，它把它放入它的缓存。所以当objc_msgSend查找一个类的选择器，它首先搜索类缓存。这是基于这样的理论：如果你在类上调用一个消息，你可能以后再次调用该消息。<br>为了加速消息分发， 系统会对方法和对应的地址进行缓存，就放在上述的objc_cache，所以在实际运行中，大部分常用的方法都是会被缓存起来的，Runtime系统实际上非常快，接近直接执行内存地址的程序速度。</p><h2 id="分类Category（object-category）"><a href="#分类Category（object-category）" class="headerlink" title="分类Category（object_category）"></a>分类Category（object_category）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct category_t &#123; </div><div class="line">    const char *name;                           //className</div><div class="line">    classref_t cls;                             //要扩展的类对象，在runtime阶段通过name对应到类对象</div><div class="line">    struct method_list_t *instanceMethods;      //给类添加的实例方法列表</div><div class="line">    struct method_list_t *classMethods;         //类类添加的类方法列表</div><div class="line">    struct protocol_list_t *protocols;          //实现的所有协议列表</div><div class="line">    struct property_list_t *instanceProperties; //所有属性 非实例变量，通过objc_setAssociatedObject和objc_getAssociatedObject增加</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="一-Runtime-—-消息传递机制"><a href="#一-Runtime-—-消息传递机制" class="headerlink" title="一.Runtime — 消息传递机制"></a>一.Runtime — 消息传递机制</h2><p>在OC中，消息和方法的绑定是在运行时进行的，一个对象的方法像这样[obj foo]，编译器转成消息发送objc_msgSend(obj, foo)。消息传递机制的关键在于编译器对每个类和对象的结构的构建，每个类结构包含两个基本元素：指向父类的指针和类调度表。这个表罗列了他们定义的有明确类特征的方法的地址的方法选择器。</p><p><img src="http://note.youdao.com/favicon.ico" alt="image"><br>当一个消息传递给一个对象的时候，消息函数沿着这个对象的isa指针在调度表找到它建立起方法选择器的类结构。如果它不能在这里发现选择器，obic_msgSend根据指针找到它的父类，在父类的调度表中寻找选择器。连续失败导致objc_msgSend沿着类继承结构直到寻找到NSObject类。一旦确定选择器的位置，函数调用表中的方法并且把它传给接收对象的数据结构。</p><p>objc_msgSend 方法定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OBJC_EXPORT id objc_msgSend(id self, SEL op, ...)</div></pre></td></tr></table></figure><p>具体消息传递在Runtime时执行的流程是这样的（具体类对象/元类的定义可以参见<a href="http://note.youdao.com/" target="_blank" rel="external">这里</a>）：</p><ol><li>首先，通过obj的isa指针找到它的 class ;</li><li>在 class 的 method list 找 foo 方法 ;</li><li>如果 class 中没到 foo，继续往它的 superclass 中找 ;</li><li>一旦找到 foo 这个函数，就去执行它的实现IMP 。</li></ol><blockquote><p> 但是如果每次都按照这个流程执行的话，会有一个问题：一个class 往往只有 20% 的函数会被经常调用，可能占总调用次数的 80% 。每个消息都需要遍历一次objc_method_list，效率明显低下，很不合理。<br>— 。如果把经常被调用的函数缓存下来，那可以大大提高函数查询的效率。这也就是objc_class 中另一个重要成员objc_cache 做的事情 - 再找到foo 之后，把foo 的method_name 作为key ，method_imp作为value 给存起来。当再次收到foo 消息的时候，可以直接在cache 里找到，避免去遍历objc_method_list。从前面的源代码可以看到objc_cache是存在objc_class 结构体中的。</p></blockquote><h2 id="二-Runtime-—-消息转发"><a href="#二-Runtime-—-消息转发" class="headerlink" title="二.Runtime — 消息转发"></a>二.Runtime — 消息转发</h2><p><img src="http://note.youdao.com/favicon.ico" alt="image"></p><p>由上图可以看到，消息转发中有3次可以调整的机会，防止unrecognized selector报错，</p><h3 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h3><p>首先，Objective-C运行时会调用 +resolveInstanceMethod:或者 +resolveClassMethod:，让你有机会提供一个函数实现。如果你添加了函数并返回YES， 那运行时系统就会重新启动一次消息发送的过程。</p><h3 id="备用接收者"><a href="#备用接收者" class="headerlink" title="备用接收者"></a>备用接收者</h3><p>如果目标对象实现了-forwardingTargetForSelector:，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。</p><h3 id="完整消息转发"><a href="#完整消息转发" class="headerlink" title="完整消息转发"></a>完整消息转发</h3><p>如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。<br>首先它会发送-methodSignatureForSelector:消息获得函数的参数和返回值类型。如果-methodSignatureForSelector:返回nil ，Runtime则会发出 -doesNotRecognizeSelector: 消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation 对象并发送 -forwardInvocation:消息给目标对象。</p><p>从打印结果来看，我们实现了完整的转发。通过签名，Runtime生成了一个对象anInvocation，发送给了forwardInvocation，我们在forwardInvocation方法里面让Person对象去执行了foo函数。签名参数v@:怎么解释呢，这里苹果文档Type <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="external">Encodings有详细的解释</a>。<br>以上就是Runtime的三次转发流程。下面我们讲讲Runtime的实际应用。</p><p>##RunTime — 应用</p><p>关联对象(Objective-C Associated Objects)给分类增加属性<br>方法魔法(Method Swizzling)方法添加和替换和KVO实现<br>消息转发(热更新)解决Bug(JSPatch)<br>实现NSCoding的自动归档和自动解档<br>实现字典和模型的自动转换(MJExtension)</p><p>swizzling应该只在+load中完成。 在 Objective-C 的运行时中，每个类有两个方法都会自动调用。+load 是在一个类被初始装载时调用，+initialize 是在应用第一次调用该类的类方法或实例方法前调用的。两个方法都是可选的，并且只有在方法被实现的情况下才会被调用。<br>swizzling应该只在dispatch_once 中完成,由于swizzling 改变了全局的状态，所以我们需要确保每个预防措施在运行时都是可用的。原子操作就是这样一个用于确保代码只会被执行一次的预防措施，就算是在不同的线程中也能确保代码只执行一次。Grand Central Dispatch 的 dispatch_once满足了所需要的需求，并且应该被当做使用swizzling 的初始化单例方法的标准。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RunTime&quot;&gt;&lt;a href=&quot;#RunTime&quot; class=&quot;headerlink&quot; title=&quot;RunTime&quot;&gt;&lt;/a&gt;RunTime&lt;/h1&gt;&lt;p&gt;RunTime，简称运行时，是用C和汇编编写的一套底层API，是Objective-C面向对象和动态
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://yuweizhong.github.io/yu.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 响应者链</title>
    <link href="https://yuweizhong.github.io/yu.github.io/2018/04/26/iOS%20%E5%93%8D%E5%BA%94%E8%80%85%E9%93%BE/"/>
    <id>https://yuweizhong.github.io/yu.github.io/2018/04/26/iOS 响应者链/</id>
    <published>2018-04-26T08:32:10.000Z</published>
    <updated>2018-05-09T09:12:36.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS-响应者链"><a href="#iOS-响应者链" class="headerlink" title="iOS 响应者链"></a>iOS 响应者链</h1><p>谈到iOS内的响应者链，首先想到的肯定是 UIResponder对象，用户点击屏幕，传递响应事件，直至对响应事件做出反应。</p><p>而这其中具体的事件响应又是如何呢？</p><h1 id="UIResponder对象"><a href="#UIResponder对象" class="headerlink" title="UIResponder对象"></a>UIResponder对象</h1><p>UIResponder是事件的响应类，里面提供了那些需要响应并处理事件的一组接口，包括触摸事件（touch events）和运动事件（motion events）。包括我们熟悉的UIKit类中的UIApplication、UIView、UIViewController等几个类都是直接继承与UIResponder类，这些对象都是一系列响应对象（响应者）。</p><p>UIResponder对象有一个nextResponder属性</p><p><code>@property(nonatomic, readonly, nullable) UIResponder *nextResponder;</code></p><p>对于nextResponder的理解，应该是这样的：</p><ul><li><p>UIView</p><p>UIView的nextResponder是管理该view的VC或是其父视图superView</p></li><li>UIViewController</li><li>若该VC是由某个VC presented的，则该VC的nextResponder则是发起presented的那个VC；</li><li>其余情况下VC的nextResponder则是UIWindow；</li><li><p>UIWindow</p><p>其nextResponder为UIApplication对象</p></li><li></li><li><p>UIApplication</p><p>其nextResponder为AppDelegate，对于AppDelegate对象则返回nil</p></li></ul><h2 id="响应链工作"><a href="#响应链工作" class="headerlink" title="响应链工作"></a>响应链工作</h2><p> UIView中有一个方法</p><p><code>- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;</code></p><p><strong>UIKit就是通过基于视图的hit-testing来确定touch事件发生的位置，再将touch的位置和视图层级中的view边界进行对比，判断事件的响应。</strong></p><p>而符合响应者的要求包括以下几条：</p><ul><li>响应者 hidden属性不为YES；</li><li>响应者 透明度不为 0；</li><li>响应者的 userInteractionEnabled 不为NO;</li><li>响应者在事件touch区域内；</li><li>遍历响应者subview，从上至下遍历，直至找到合适的view作响应者。</li></ul><p>例如对于以下层级视图，当用户选择其重叠区域点击时，响应者流程如下：</p><p><img src="https://raw.githubusercontent.com/yuweizhong/Resources/master/Img/redAndGreen.png" alt="ViewController_RedViewAndGreenView.png"></p><ol><li>AppDelegate的 window收到事件，开始执行hitTest方法，符合要求，开始遍历子view；</li><li>事件传到VC.view上，并开始执行hitTest方法，符合要求，开始遍历子view；</li><li>VC.view上有两个子view(RedView和GreenView)，GreenView在RedView之上，所以GreenView先执行hitTest方法，若符合响应者要求，（开始遍历子view，没有子View）则返回GreenView；若GreenView不符合响应者要求，则RedView执行hitTest方法，判断是否符合响应者要求…..</li><li>返回符合响应者要求的View</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS-响应者链&quot;&gt;&lt;a href=&quot;#iOS-响应者链&quot; class=&quot;headerlink&quot; title=&quot;iOS 响应者链&quot;&gt;&lt;/a&gt;iOS 响应者链&lt;/h1&gt;&lt;p&gt;谈到iOS内的响应者链，首先想到的肯定是 UIResponder对象，用户点击屏幕，传递响应
      
    
    </summary>
    
    
      <category term="UIResponder" scheme="https://yuweizhong.github.io/yu.github.io/tags/UIResponder/"/>
    
  </entry>
  
  <entry>
    <title>RunTime小例子</title>
    <link href="https://yuweizhong.github.io/yu.github.io/2018/03/21/view/"/>
    <id>https://yuweizhong.github.io/yu.github.io/2018/03/21/view/</id>
    <published>2018-03-21T12:32:10.000Z</published>
    <updated>2018-03-23T07:51:18.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、什么是Runtime"><a href="#一、什么是Runtime" class="headerlink" title="一、什么是Runtime"></a>一、什么是Runtime</h1><pre><code>Runtime，中文翻译可以说是 运行时，是一套底层的C语言API;在OC语言中，函数的调用都是在运行时决定的，甚至可以在运行时改变类的具体实现，包括类中的私有方法和属性等等。OC语言内，所有的函数方法调用都是都是向对象发送消息；</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id objc_msgSend ( id self, SEL op, ... );</div></pre></td></tr></table></figure><h1 id="二、RunTime使用"><a href="#二、RunTime使用" class="headerlink" title="二、RunTime使用"></a>二、RunTime使用</h1><p>通过Runtime机制，我们可以</p><ol><li>动态获取某个类的所有变量和方法</li><li>修改某个类中私有变量的值</li><li>为某个类增加新属性和弦方法</li><li>实现某个类下的方法交换</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、什么是Runtime&quot;&gt;&lt;a href=&quot;#一、什么是Runtime&quot; class=&quot;headerlink&quot; title=&quot;一、什么是Runtime&quot;&gt;&lt;/a&gt;一、什么是Runtime&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;Runtime，中文翻译可以说是 运行时，是
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>resolveInstanceMethod和resolveClassMethod</title>
    <link href="https://yuweizhong.github.io/yu.github.io/2018/03/02/OC%E6%9C%AA%E7%9F%A5%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/"/>
    <id>https://yuweizhong.github.io/yu.github.io/2018/03/02/OC未知消息转发/</id>
    <published>2018-03-02T10:33:15.000Z</published>
    <updated>2018-03-02T06:44:23.378Z</updated>
    
    <content type="html"><![CDATA[<p>在iOS中，消息发送是通过，objc_msgSend(id, SEL, …)来实现的。<br>首先会在对象的类对象的cache,method list以及父类对象的cache,method list依次查找SEL对应的IMP。<br>如果向一个对象发送无法它无法处理的消息，一般会出现crash。</p><p>通过实现动态决议和消息转发。只有当动态决议无法决议selector的实现，才会尝试进行消息转发，可以避免一些crash情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//针对实例方法</div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)name &#123;</div><div class="line"> NSLog(@&quot; &gt;&gt; Instance resolving %@&quot;, NSStringFromSelector(name)); </div><div class="line"> if (name == @selector(MissMethod)) &#123; </div><div class="line"> /*</div><div class="line"> **就能在运行期动态地为 name 这个 selector 添加实现：dynamicMethodIMP。class_addMethod是运行时函数，所以需要导入头文件：objc/runtime.h。</div><div class="line"> */</div><div class="line"> class_addMethod([self class], name, (IMP)dynamicMethodIMP, &quot;v@:&quot;);</div><div class="line">  return YES; &#125; </div><div class="line">  return [super resolveInstanceMethod:name]; </div><div class="line">&#125;</div><div class="line"></div><div class="line">//针对类方法</div><div class="line"> + (BOOL)resolveClassMethod:(SEL)name &#123; </div><div class="line"> NSLog(@&quot; &gt;&gt; Class resolving %@&quot;, NSStringFromSelector(name)); </div><div class="line"> return [super resolveClassMethod:name]; </div><div class="line"> &#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在iOS中，消息发送是通过，objc_msgSend(id, SEL, …)来实现的。&lt;br&gt;首先会在对象的类对象的cache,method list以及父类对象的cache,method list依次查找SEL对应的IMP。&lt;br&gt;如果向一个对象发送无法它无法处理的消息，
      
    
    </summary>
    
    
      <category term="method" scheme="https://yuweizhong.github.io/yu.github.io/tags/method/"/>
    
  </entry>
  
  <entry>
    <title>iOS UI界面搭建方式</title>
    <link href="https://yuweizhong.github.io/yu.github.io/2017/12/02/iOS%20%E7%95%8C%E9%9D%A2%E6%90%AD%E5%BB%BA/"/>
    <id>https://yuweizhong.github.io/yu.github.io/2017/12/02/iOS 界面搭建/</id>
    <published>2017-12-02T04:20:40.000Z</published>
    <updated>2018-01-16T06:27:10.042Z</updated>
    
    <content type="html"><![CDATA[<p>对于iOS界面的搭建，关于使用哪种方式不少人会有一些争议，纯代码、xib或者说是storyboard：</p><p><strong>纯代码</strong><br>纯手写代码，灵活容易控制，对于大型项目和团队开发较为友好，特别是在版本控制和代码管理上面，但是代码量较大，较为繁琐。现阶段很多采用Masonry手写代码布局，配合Reveal工具调试。</p><p><strong>xib&amp;storyboard</strong><br>xib出现在storyboard之前，和storyboard类似，storyboard是各个xib的集合，xib相比storyboard更小规模些。两者都可以实现控件拖拽布局，比较直观，开发较快， storyboard 中可以很方便地理清界面间的调用关系。但是两者对于代码管理不是很友好，不同版本的Xcode打开会造成xib修改，对于冲突的解决也很难看出来。对于复杂的App，storyboard的性能会差一些。</p><p><strong>因此，一般我会采用纯代码和Xib结合的方式：</strong></p><ul><li>对于复杂的、动态生成的界面，建议使用手工编写界面。</li><li>对于需要统一风格的按钮或UI控件，建议使用手工用代码来构造。方便之后的修改和复用。</li><li>对于需要有继承或组合关系的 UIView 类或 UIViewController类，建议用代码手工编写界面。</li><li>对于那些简单的、静态的、非核心功能界面，可以考虑使用 xib 或 storyboard 来完成。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于iOS界面的搭建，关于使用哪种方式不少人会有一些争议，纯代码、xib或者说是storyboard：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;纯代码&lt;/strong&gt;&lt;br&gt;纯手写代码，灵活容易控制，对于大型项目和团队开发较为友好，特别是在版本控制和代码管理上面，但是代码量较大，较
      
    
    </summary>
    
    
      <category term="UI" scheme="https://yuweizhong.github.io/yu.github.io/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>OC Basis</title>
    <link href="https://yuweizhong.github.io/yu.github.io/2017/11/03/OC%20Basis/"/>
    <id>https://yuweizhong.github.io/yu.github.io/2017/11/03/OC Basis/</id>
    <published>2017-11-03T08:41:44.000Z</published>
    <updated>2018-05-16T12:26:32.662Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Objective-C动态时特性"><a href="#1、Objective-C动态时特性" class="headerlink" title="1、Objective-C动态时特性"></a>1、Objective-C动态时特性</h3><pre><code>OC语言动态时的特性主要表现在：动态类型、动态绑定、动态加载。</code></pre><ul><li><p>动态类型，区分于静态类型（int、float…），静态类型在编译时决定变量类型，类型不符合就会报错。动态类型即在运行时决定变量类型，OC中的id类型，任何对象都可以被id类型指针所指，到运行时才决定对象的类型。</p></li><li><p>动态绑定，基于动态类型，在某个实例对象被确定之后，其属性和方法也就被确定了。OC中的方法都是消息转发机制，当我们向一个对象发送息发送-respondsToSelector:或者 -instancesRespondToSelector:等来确定对象是否可以对某个方法做出响应时，在消息转发机制处理之前，对应的类 的+resolveClassMethod:和+resolveInstanceMethod:将会被调用，可以有机会动态地向类或者实例添加新的方法（避免崩溃），也即类的实现是可以动态绑定；isKindOfClass类似。</p></li><li><p>动态加载，主要是icon图片的加载会根据设备状态自动选取@2x @3x图片进行显示。</p></li></ul><h3 id="2、delegate、datasource-amp-block"><a href="#2、delegate、datasource-amp-block" class="headerlink" title="2、delegate、datasource&amp;block"></a>2、delegate、datasource&amp;block</h3><ul><li>delegate是委托回调，在OC中是一个类委托另一个类实现某个方法，一个对象会对他的delegate发送消息，执行delegate里的方法</li><li>datasource是数据源，主要和数据内容有关，一般为cell的属性和各种构造函数，是对数据源的处理。</li><li>block是简单的回调，相比delegate代码更加集中统一，写法更加简练，但要注意循环引用。在公共接口和方法较多情况下可以选择delegate，在异步回调（AFNetWorking…）或者简单的回调选择block，block涉及到栈内存和堆内存的拷贝，运行成本较大；而delegate只是一个对象指针的保存和回调。</li></ul><h3 id="3、让对象实现copy功能"><a href="#3、让对象实现copy功能" class="headerlink" title="3、让对象实现copy功能"></a>3、让对象实现copy功能</h3><p>实现copy功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying与 NSMutableCopying协议。<br>声明 NSCopying 协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;NSCopying&gt;</div></pre></td></tr></table></figure></p><p>实现 NSCopying 协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)copyWithZone:(NSZone *)zone;</div></pre></td></tr></table></figure></p><h3 id="4、深拷贝-amp-浅拷贝"><a href="#4、深拷贝-amp-浅拷贝" class="headerlink" title="4、深拷贝&amp;浅拷贝"></a>4、深拷贝&amp;浅拷贝</h3><ul><li><p>浅拷贝：指针拷贝，内存地址并未改变，只是将对象内存地址多了一个引用，在拷贝结束之后，两个对象的值不仅相同，而且对象所指的内存地址都是一样的。</p></li><li><p>深拷贝：内容拷贝，拷贝一个对象的具体内容，拷贝结束之后，两个对象的值虽然是相同的，但是指向的内存地址是不同的。两个对象之间也互不影响，互不干扰。</p></li><li><p>非集合类对象：对一个不可变对象进行copy操作，只仅仅是指针复制，进行mutableCopy操作，是内容复制；而对一个可变对象进行copy和mutableCopy操作，都是内容复制。</p></li></ul><p>-集合类对象：不可变对象copy相同，进行mutableCopy操作时，虽然数组内存地址发生了变化，但是数组元素的内存地址并没有发生变化（单层深拷贝）；对于可变对象，copy和mutableCopy都是内容复制，内存地址变化，但是数组元素的内存地址并没有发生变化（单层深拷贝）<br>集合类对象和非集合类对象的copy与mutablecopy<br>建议参照此篇分析 与网上大多数看法不一致 但个人感觉可信度较高 [<a href="https://joeshang.github.io/" target="_blank" rel="external">https://joeshang.github.io/</a>]</p><p>demo1:<br>NSString <em>origStr = @”123456”;<br>NSString </em>strCopy = [origStr copy];<br>NSMutableString *strMtCopy = [origStr mutablecopy];</p><p>demo2:<br>NSMutableStr <em>origStr = [NSMutableString stringWithFormat:@”123456”];<br>NSString </em>strCopy = [origStr copy];<br>NSMutableStr *strMuCopy = [origStr mutablecopy];</p><p>demo3:<br>NSArray <em>arr = @[@”a”, @”b”,@”c”];<br>NSArray </em>arrCopy = [array copy];<br>NSMutableArray *arrayMCopy = [array mutableCopy];</p><p>demo4:<br>NSMutableArray <em>arr =[ [NSMutableArray alloc] initWithObject:@”1”,@”2”,@”3”,nil];<br>NSArray </em>arrCopy = [array copy];<br>NSMutableArray *arrayMCopy = [array mutableCopy];</p><h3 id="5、进程-amp-线程-同步-amp-异步-并行-amp-串行"><a href="#5、进程-amp-线程-同步-amp-异步-并行-amp-串行" class="headerlink" title="5、进程&amp;线程 同步&amp;异步 并行&amp;串行"></a>5、进程&amp;线程 同步&amp;异步 并行&amp;串行</h3><p>1、进程是计算机操作系统分配资源的单位；线程是进程的基本执行单元，一个进程内的所有任务都在线程中执行；两者都是操作系统体积功的程序运行的基本单元，知识资源管理方式不同。进程有独立的地址空间，而线程只是一个进程中所执行的任务。线程有自己的堆栈空间和局部变量，没有单独的地址空间。一个进程内部可以有多个线程并发执行。<br>2、同步和异步是在线程单元中的概念。同步指在当前线程执行任务，不开启新的线程；异步指开启新的线程执行任务，不影响当前线程任务的执行。<br>3、并行与串行是线程内任务的执行方式。并行指多个任务同时执行，串行指按顺序执行，执行完一个任务后执行下一个（并发指处理多任务的能力，可以是多任务在同一时间段内执行，并不一定同时执行多个任务）。</p><h3 id="6、线程间通信"><a href="#6、线程间通信" class="headerlink" title="6、线程间通信"></a>6、线程间通信</h3><p>1、NSThread<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;</div><div class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait NS_AVAILABLE(10_5, 2_0);</div></pre></td></tr></table></figure></p><p>2、GCD<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">     </div><div class="line"> &#125;)</div><div class="line"> dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line"> </div><div class="line"> &#125;)</div></pre></td></tr></table></figure></p><p>GCD其他函数方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//延迟方法</div><div class="line"> dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(/*延迟时间*/  *NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">   &#125;</div><div class="line">//单例</div><div class="line">  static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">       //只执行一次的代码</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></p><p>3、NSOperation<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//创建线程队列</div><div class="line">NSOperstionQueue *queue =[[NSOperationQueue alloc] init];</div><div class="line">NSOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    //线程任务</div><div class="line">&#125;];</div><div class="line">[queue addOperation：operation];</div><div class="line">//获取main队列</div><div class="line">NSOperstionQueue *mainQueue = [NSOperationQueue mainQueue];</div><div class="line">[mainQueue addOperationWithBlock:^&#123;</div><div class="line">   //线程任务 </div><div class="line">&#125;];</div></pre></td></tr></table></figure></p><p> <a href="https://www.jianshu.com/p/6e6f4e005a0b" target="_blank" rel="external">多线程介绍可见这篇连接较详细</a></p><h3 id="7、iOS数据持久化"><a href="#7、iOS数据持久化" class="headerlink" title="7、iOS数据持久化"></a>7、iOS数据持久化</h3><ul><li>plist文件</li><li>Perference（UserDefaule）</li><li>NSKeyedArchiver（归档）：遵从NSCoding协议，实现解码和编码两个方法</li><li>SQLite3：使用三方库FMDB较为方便</li><li>CoreData</li></ul><h3 id="8、App生命周期"><a href="#8、App生命周期" class="headerlink" title="8、App生命周期"></a>8、App生命周期</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</div><div class="line">&#123;</div><div class="line">    // Override point for customization after application launch.</div><div class="line">    NSLog(@&quot;didFinishLaunchingWithOptions&quot;);</div><div class="line">    return YES;</div><div class="line">&#125;</div><div class="line">                            </div><div class="line">- (void)applicationWillResignActive:(UIApplication *)application</div><div class="line">&#123;</div><div class="line">    // Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.</div><div class="line">    // Use this method to pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. Games should use this method to pause the game.</div><div class="line">    NSLog(@&quot;WillResignActive&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)applicationDidEnterBackground:(UIApplication *)application</div><div class="line">&#123;</div><div class="line">    // Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later. </div><div class="line">    // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.</div><div class="line">    NSLog(@&quot;DidEnterBackground&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)applicationWillEnterForeground:(UIApplication *)application</div><div class="line">&#123;</div><div class="line">    // Called as part of the transition from the background to the inactive state; here you can undo many of the changes made on entering the background.</div><div class="line">    NSLog(@&quot;WillEnterForeground&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)applicationDidBecomeActive:(UIApplication *)application</div><div class="line">&#123;</div><div class="line">    // Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.</div><div class="line">    NSLog(@&quot;DidBecomeActive&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)applicationWillTerminate:(UIApplication *)application</div><div class="line">&#123;</div><div class="line">    // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.</div><div class="line">    NSLog(@&quot;WillTerminate&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>首次启动程序</strong><br>didFinishLaunchingWithOptions<br>DidBecomeActive<br><strong>从前台到后台</strong><br>WillResignActive<br>DidEnterBackground<br><strong>从后台到前台</strong><br>WillEnterForeground<br>DidBecomeActive</p><h3 id="9、NSCache-amp-NSDictionary"><a href="#9、NSCache-amp-NSDictionary" class="headerlink" title="9、NSCache&amp;NSDictionary"></a>9、NSCache&amp;NSDictionary</h3><p>两者基本用法相似。NSCache是线程安全的，可以指定缓存的限额，当缓存超出限额或者内存不足时NSCache会自动释放内存；NSMutableDictionary线程不安全。NScache相比功能更强大一些。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 缓存中总共可以存储多少条</div><div class="line">_cache.countLimit = 5;</div><div class="line">// 缓存的数据总量为多少</div><div class="line">_cache.totalCostLimit = 1024 * 5;</div><div class="line"></div><div class="line">//delegate</div><div class="line">//当缓存被移除的时候执行</div><div class="line">- (void)cache:(NSCache *)cache willEvictObject:(id)obj&#123;</div><div class="line">    NSLog(@&quot;缓存移除  %@&quot;,obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="10、description"><a href="#10、description" class="headerlink" title="10、description"></a>10、description</h3><p>description方法默认返回对象的描述信息(默认实现是返回类名和对象的内存地址)，重写description方法之后可以用来输出对象内部变量的值。调用NSLog(@”%@”, object);这会自动调用object的description方法来输出Object的描述信息.<br><strong>Attention：不要在description方法中同时使用%@和self，否则会陷入死循环，循环调用description方法</strong></p><h3 id="11、ARC"><a href="#11、ARC" class="headerlink" title="11、ARC"></a>11、ARC</h3><p>   ARC：Automatic Reference Counting 自动引用计数，苹果引入的一种内存管理机制。只要是为了解决MRC下手动创建和释放内存而造成的内存泄漏程序崩溃等问题。</p><h3 id="12、assign-VS-weak-；block-VS-weak"><a href="#12、assign-VS-weak-；block-VS-weak" class="headerlink" title="12、assign VS weak ；block VS weak"></a>12、assign VS weak ；<strong>block VS </strong>weak</h3><pre><code>assign用于修饰基础类型 float int 等等，weak用于修饰delegate block等对象类型，weak修饰的对象在对象废弃后会自动取消引用计数并置为nil，不会造成野指针；__block不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型。__block对象可以在block中被重新赋值，__weak不可以。__weak只能在ARC模式下使用，也只能修饰对象（NSString），不能修饰基本数据类型（int）。</code></pre><h3 id="13、KVC-KVO-NSNotifiction-delegate-block"><a href="#13、KVC-KVO-NSNotifiction-delegate-block" class="headerlink" title="13、KVC KVO NSNotifiction delegate block"></a>13、KVC KVO NSNotifiction delegate block</h3><pre><code>KVC: key value coding，根据key 的值访问属性KVO：观察者模式，对某个对象添加观察 实现oberserveValueForKeyPath：NSNotifiction：一对多的通知方式delegate：代理，一对一模式，将某些方法教给代理去执行block：delegate的灵活化方式，函数式编程的一种形式KVO一般的使用场景是数据，需求是数据变化，比如股票价格变化，我们一般使用KVO（观察者模式）。delegate一般的使用场景是行为，需求是需要别人帮我做一件事情，比如买卖股票，我们一般使用delegate。Notification一般是进行全局通知，比如利好消息一出，通知大家去买入。delegate是强关联，就是委托和代理双方互相知道，你委托别人买股票你就需要知道经纪人，经纪人也不要知道自己的顾客。Notification是弱关联，利好消息发出，你不需要知道是谁发的也可以做出相应的反应，同理发消息的人也不需要知道接收的人也可以正常发出消息。一般在block中修改变量都需要事先加__block进行修饰。在非arc中，__block修饰的变量的引用计算是不变的。在arc中，会引用到，并且计算+1；非arc下可使用（arc直接使用__weak即可）</code></pre><h3 id="14、MVC-vs-MVVM"><a href="#14、MVC-vs-MVVM" class="headerlink" title="14、MVC vs MVVM"></a>14、MVC vs MVVM</h3><pre><code>...</code></pre><h3 id="15、NSNumber-和-NSInteger"><a href="#15、NSNumber-和-NSInteger" class="headerlink" title="15、NSNumber 和 NSInteger"></a>15、NSNumber 和 NSInteger</h3><pre><code>NSNumber是类 ，而NSInteger是一个基本类型</code></pre><h3 id="16、如何重写类方法"><a href="#16、如何重写类方法" class="headerlink" title="16、如何重写类方法"></a>16、如何重写类方法</h3><pre><code>1、在子类中实现一个同基类名字一样的静态方法2、在调用的时候不要使用类名调用，而是使用[self class]的方式调用。原理，用类名调用是早绑定，在编译期绑定，用[self class]是晚绑定，在运行时决定调用哪个方法。</code></pre><h3 id="17、category-extension-继承"><a href="#17、category-extension-继承" class="headerlink" title="17、category/extension/继承"></a>17、category/extension/继承</h3><pre><code>category是在现有类的基础上添加新的方法，利用objective-c 的动态运行时分配机制，可以为现有类添加新方法。可以在分类中添加方法和成员变量，但是添加的成员变量不会自动生成setter和getter方法，需要在实现部分给出实现。extension就是匿名的分类，只有头文件没有实现文件。只能扩展方法，不能添加成员变量。扩展的方法只能在原类中实现。例如你扩展NSString,那么你只能在NSString的.m实现（这是不可能的），所以尽量少用扩展。用分类就可以了在iOS中继承是单继承，既只能有一个父类。在继承中，子类可以使用父类的方法和变量，当子类想对本类或者父类的变量进行初始化，那么需要重写init（）方法 。父类也可以访问子类的方法和成员变量。、</code></pre><h3 id="18、将一个自定义对象序列化至磁盘"><a href="#18、将一个自定义对象序列化至磁盘" class="headerlink" title="18、将一个自定义对象序列化至磁盘"></a>18、将一个自定义对象序列化至磁盘</h3><pre><code>自定义对象实现&lt;NSCoding&gt;协议，实现-(instancetype)initWithCoder:(NSCoder *)aDecoder 方法和-(void)encodeWithCoder:(NSCoder *)aCoder方法使用NSKeyedArchiver进行读写就可以了。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Objective-C动态时特性&quot;&gt;&lt;a href=&quot;#1、Objective-C动态时特性&quot; class=&quot;headerlink&quot; title=&quot;1、Objective-C动态时特性&quot;&gt;&lt;/a&gt;1、Objective-C动态时特性&lt;/h3&gt;&lt;pre&gt;&lt;cod
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>UIWindow遇到的问题</title>
    <link href="https://yuweizhong.github.io/yu.github.io/2017/10/18/iOS%20%E9%81%87%E8%A7%81%E7%9A%84UIWindow%E9%97%AE%E9%A2%98/"/>
    <id>https://yuweizhong.github.io/yu.github.io/2017/10/18/iOS 遇见的UIWindow问题/</id>
    <published>2017-10-18T11:22:45.000Z</published>
    <updated>2018-01-03T11:29:50.978Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目里遇到了一个关于UIWindow的问题，便去查找了一下UIWIndow，故作此记录</p><p><strong>UIWindowLevel</strong><br>window层级主要有下面三类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UIKIT_EXTERN const UIWindowLevel UIWindowLevelNormal;</div><div class="line">UIKIT_EXTERN const UIWindowLevel UIWindowLevelAlert;</div><div class="line">UIKIT_EXTERN const UIWindowLevel UIWindowLevelStatusBar</div></pre></td></tr></table></figure></p><p><strong>keyWindow</strong></p><p>在ios 中用 [UIApplication sharedApplication].windows可以获取应用内所有设置的window：</p><h5 id="1-UIWIndow"><a href="#1-UIWIndow" class="headerlink" title="(1)UIWIndow"></a>(1)UIWIndow</h5><p>程序主要的keyWindow，程序展示的窗口</p><h5 id="2-UITextEffectsWindow"><a href="#2-UITextEffectsWindow" class="headerlink" title="(2)UITextEffectsWindow"></a>(2)UITextEffectsWindow</h5><p>这是iOS8引入的一个新window，是键盘所在的window。它的windowLevel是10，高于UIWindowLevelNormal。</p><h5 id="3-UIRemoteKeyboardWindow"><a href="#3-UIRemoteKeyboardWindow" class="headerlink" title="(3)UIRemoteKeyboardWindow"></a>(3)UIRemoteKeyboardWindow</h5><p>iOS9之后,新增了一个类型为 UIRemoteKeyboardWindow 的窗口用来显示键盘按钮。</p><p>当自定义添加window至页面上时（例如添加全局的悬浮窗口）每次弹窗 UIActionSheet或UIAlertView之后，再用[[UIApplication sharedApplication].keyWindow]获取keywindow时候，会取到最外层设置的UIWindow（项目中的全局悬浮窗口），就可能出现问题。</p><p>因为在打开UIActionSheet或UIAlertView弹窗时候，程序为了让弹框出现在最外层，会新建一个临时的UIWindow，并且层级最高，并设置为keywindow。在弹框消失后keywindow会自动变成下一层级的UIWindow（当前层级最高的UIwindow），即指向了项目中的全局悬浮窗口。 </p><p><strong>Add：使用iOS8后出现的UIAlertController不会出现上述问题</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近项目里遇到了一个关于UIWindow的问题，便去查找了一下UIWIndow，故作此记录&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UIWindowLevel&lt;/strong&gt;&lt;br&gt;window层级主要有下面三类&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;
      
    
    </summary>
    
    
      <category term="UIWindow" scheme="https://yuweizhong.github.io/yu.github.io/tags/UIWindow/"/>
    
  </entry>
  
  <entry>
    <title>iOS @property</title>
    <link href="https://yuweizhong.github.io/yu.github.io/2017/10/06/iOS%20@property/"/>
    <id>https://yuweizhong.github.io/yu.github.io/2017/10/06/iOS @property/</id>
    <published>2017-10-06T07:50:36.000Z</published>
    <updated>2018-01-10T12:26:26.512Z</updated>
    
    <content type="html"><![CDATA[<p>对于property，iOS开发者并不会陌生，无时无刻不在接触可是<strong>@property 的本质是什么？</strong></p><blockquote><p>@property = ivar + getter + setter;</p></blockquote><p>“属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）<br>“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为 Objective-C 2.0 的一部分。<br>property在runtime中是objc_property_t定义如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_property *objc_property_t;</div></pre></td></tr></table></figure></p><p>而objc_property是一个结构体，包括name和attributes，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct property_t &#123;</div><div class="line">     const char *name;</div><div class="line">     const char *attributes;</div><div class="line"> &#125;;</div></pre></td></tr></table></figure></p><p>而attributes本质是objc_property_attribute_t，定义了property的一些属性，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/// Defines a property attribute</div><div class="line">typedef struct &#123;</div><div class="line">    const char *name;           /**&lt; The name of the attribute */</div><div class="line">    const char *value;          /**&lt; The value of the attribute (usually empty) */</div><div class="line">&#125; objc_property_attribute_t;</div></pre></td></tr></table></figure></p><h4 id="property属性关键字"><a href="#property属性关键字" class="headerlink" title="@property属性关键字"></a>@property属性关键字</h4><ul><li><p>nonatomic —原子性<br>在默认情况下，由编译器合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用自旋锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的” ( atomic) )，但是仍然可以在属性特质中写明这一点，编译器不会报错。若是自己定义存取方法，那么就应该遵从与属性特质相符的原子性。</p></li><li><p>readwrite(读写)、readonly (只读) — 读/写权限</p></li><li><p>assign、strong、 weak、unsafe_unretained、copy — 内存管理语义</p></li></ul><ol><li>assign<br>简单赋值，不更改索引计数。 对基础数据类型 （例如NSInteger，CGFloat）和C数据类型（int, float, double, char, 等），适用简单数据类型。</li><li>strong(强引用)<br>ARC下的一个关键字。被强引用指向的内存不会被释放。强引用会对引用计数+1，从而拓展对象的生命周期。（retain调用的ARC版本）</li><li>weak弱引用：<br>弱引用是一种特殊的引用类型。它不会增加引用计数因而不会拓展对象的生命周期。当没有强引用指向对象时，弱引用会被置为nil。在对象回收时，weak具有安全性——指针将自动被设置为nil，避免野指针的出现</li><li>_unsafe_unretained:<br>与weak类似，只是没有强引用指向对象时，_unsafe_unretained不会被置为nil；</li><li>copy<br>建立一个索引计数为1的对象，然后释放旧对象。一般适用于存在可变对象的类型（例 NSString NSDictionary…）</li><li>atomic<br>atomic意为操作是原子的，意味着只有一个线程访问实例变量.属性的存取方法是线程安全的,很少使用，因为比较影响效率，性能比nonatomic差。</li><li>nonatomic<br>非原子的，可以被多个线程访问。它的效率比atomic快。禁止多线程，变量保护，提高性能，不能保证在多线程环境下的安全性，在单线程和明确只有一个线程访问的情况下广泛使用。<br>8.@synthesize 和 @dynamic<br>@property 有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize 和 @dynamic都没写，那么默认的就是 @syntheszie var = _var;<br>@synthesize ：如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@syntheszie var = _var;</div></pre></td></tr></table></figure></li></ol><p>@dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter 方法和 @getter 方法，编译的时候没问题，但是当程序运行到 instance.var = someVar，由于缺 setter 方法会导致程序崩溃；或者当运行到 someVar = var 时，由于缺 getter方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。</p><p><strong>A. 什么情况使用 weak 关键字，相比 assign 有什么不同？</strong></p><h5 id="什么情况使用-weak-关键字？"><a href="#什么情况使用-weak-关键字？" class="headerlink" title="什么情况使用 weak 关键字？"></a>什么情况使用 weak 关键字？</h5><p>在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性<br>自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong</p><h5 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h5><p>weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。 而 assign 的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或 NSlnteger 等)的简单赋值操作。</p><p>assign 可以用非 OC 对象,而 weak 必须用于 OC 对象</p><p><strong>B. 怎么用 copy 关键字？</strong></p><p>用途：</p><p>NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。<br>block 也经常使用 copy 关键字,block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在 ARC 中写不写都行；</p><p>copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。 当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。</p><p><strong>C.用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</strong></p><p>str1使用copy关键字 str2使用strong关键字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">-(void)test</div><div class="line">&#123;</div><div class="line">    NSMutableString*str=[NSMutableString stringWithFormat:@&quot;helloworld&quot;];</div><div class="line">    self.str1=str;</div><div class="line">    self.str2=str;</div><div class="line">    NSLog(@&quot;str:%p--%p&quot;,str,&amp;str);</div><div class="line">    NSLog(@&quot;copy_str:%p--%p&quot;,_str1,&amp;_str1);</div><div class="line">    NSLog(@&quot;strong_str:%p--%p&quot;,_str2,&amp;_str2);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2017-09-16 15:21:55.910 APP[1236:78490] str:0x600000075cc0--0x7fff5bd7c9d8</div><div class="line">2017-09-16 15:21:55.910 APP[1236:78490] copy_str:0x600000026e60--0x7fc66cc06358</div><div class="line">2017-09-16 15:21:55.911 APP[1236:78490] strong_str:0x600000075cc0--0x7fc66cc06360</div></pre></td></tr></table></figure><p>经过copy关键字修饰过的str1没有因为str的变化而变化，经过strong修饰过的str2却随str的改变而改变。对于希望字符串的值不跟着str变化，使用用copy来设置string的属性。如果希望字串的值跟着赋值的字串的值变化，可以使用strong。</p><p>**D.为什么不用assign修饰一个对象，而可以修饰基本数据类型？<br>assign修饰的对象（编译的时候会产生警告：Assigning retained object to unsafe property; object will be released after assignment）在释放之后，指针的地址还是存在的，并没有被置为nil，造成野指针。对象分配在堆上的某块内存，如果在后续的内存分配中，刚好分到了这块地址，程序就会crash。而基础数据类型是分配在栈上，栈的内存会由系统自己自动处理回收，不会造成野指针。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于property，iOS开发者并不会陌生，无时无刻不在接触可是&lt;strong&gt;@property 的本质是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;@property = ivar + getter + setter;&lt;/p&gt;
&lt;/blockqu
      
    
    </summary>
    
    
      <category term="iOS property copy weak strong" scheme="https://yuweizhong.github.io/yu.github.io/tags/iOS-property-copy-weak-strong/"/>
    
  </entry>
  
  <entry>
    <title>&#39;const&amp;static&amp;extern&#39;</title>
    <link href="https://yuweizhong.github.io/yu.github.io/2017/09/15/const&amp;static&amp;extern/"/>
    <id>https://yuweizhong.github.io/yu.github.io/2017/09/15/const&amp;static&amp;extern/</id>
    <published>2017-09-15T12:00:34.000Z</published>
    <updated>2017-12-27T12:22:56.464Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、const"><a href="#1、const" class="headerlink" title="1、const"></a>1、const</h3><p>用于常量修饰<br>    （1）const用来修饰右边的基本变量或指针变量<br>    （2）被修饰的变量只读，不能被修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int  const  *p   //  *p只读 ;p变量</div><div class="line"></div><div class="line">int  * const  p  // *p变量 ; p只读</div><div class="line"></div><div class="line"> const  int   * const p //p和*p都只读</div><div class="line"></div><div class="line"> int  const  * const  p   //p和*p都只读 </div><div class="line"></div><div class="line"> NSString * const myStr = @&quot;myStrStr&quot;; //声明字符串的用法</div></pre></td></tr></table></figure></p><h3 id="2、宏定义"><a href="#2、宏定义" class="headerlink" title="2、宏定义"></a>2、宏定义</h3><p>#define 预定义</p><blockquote><pre><code>在预处理时（编译前）进行文本替换，没有类型，不做任何类型检查能够定义一些函数方法等等，const做不到的大量的宏定义会导致编译时间长、二进制文件过大等等</code></pre></blockquote><h3 id="3、static"><a href="#3、static" class="headerlink" title="3、static"></a>3、static</h3><p>静态变量修饰</p><h4 id="修饰局部变量："><a href="#修饰局部变量：" class="headerlink" title="修饰局部变量："></a>修饰局部变量：</h4><blockquote><pre><code>1.延长局部变量的生命周期,程序结束才会销毁。2.局部变量只会生成一份内存,只会初始化一次。3.改变局部变量的作用域。</code></pre></blockquote><h4 id="修饰全局变量"><a href="#修饰全局变量" class="headerlink" title="修饰全局变量"></a>修饰全局变量</h4><blockquote><pre><code>1.只能在本文件中访问,修改全局变量的作用域,生命周期不会改2.避免重复定义全局变量</code></pre></blockquote><p>staic &amp;&amp; const联合使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 声明一个静态的全局只读常量（当前文件）</div><div class="line"> static NSString * const myStr = @&quot;myStrStr&quot;;</div></pre></td></tr></table></figure><h3 id="4、extern"><a href="#4、extern" class="headerlink" title="4、extern"></a>4、extern</h3><blockquote><pre><code>用来获取全局变量(包括全局静态变量)的值，不能用于定义变量，定义和分配内存都在原来类中。会在当前文件中先查找是否有改变量，其次再去全局查找</code></pre></blockquote><p>extern &amp;&amp; const联合使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//全局共享的变量</div><div class="line">A.h</div><div class="line">NSString * const myStr = @&quot;myStrStr&quot;;</div><div class="line">B.h</div><div class="line">extern NSString * const myStr;</div></pre></td></tr></table></figure><h3 id="5、UIKIT-EXTERN"><a href="#5、UIKIT-EXTERN" class="headerlink" title="5、UIKIT_EXTERN"></a>5、UIKIT_EXTERN</h3><p>如果多个.m文件需要用到同一个变量的情况，在pch文件中写上面这行代码,就相当于为每一个.m文件都写这行代码</p><pre><code>//例：苹果 系统预置的通知UIKIT_EXTERN NSString *const UIKeyboardWillShowNotification;UIKIT_EXTERN NSString *const UIKeyboardDidShowNotification;UIKIT_EXTERN NSString *const UIKeyboardWillHideNotification;UIKIT_EXTERN NSString *const UIKeyboardDidHideNotification;// UIKIT_EXTERN,是经过处理的extern</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、const&quot;&gt;&lt;a href=&quot;#1、const&quot; class=&quot;headerlink&quot; title=&quot;1、const&quot;&gt;&lt;/a&gt;1、const&lt;/h3&gt;&lt;p&gt;用于常量修饰&lt;br&gt;    （1）const用来修饰右边的基本变量或指针变量&lt;br&gt;    （2）被
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS加密和苹果证书</title>
    <link href="https://yuweizhong.github.io/yu.github.io/2017/09/02/iOS%E5%8A%A0%E5%AF%86%E5%92%8C%E8%8B%B9%E6%9E%9C%E8%AF%81%E4%B9%A6/"/>
    <id>https://yuweizhong.github.io/yu.github.io/2017/09/02/iOS加密和苹果证书/</id>
    <published>2017-09-02T11:16:52.000Z</published>
    <updated>2017-12-27T07:11:18.482Z</updated>
    
    <content type="html"><![CDATA[<h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><ul><li><p>base_64加密:最常见的用于传输8位字节代码的编码方式之一。更多的感觉Base_64是作为一个字符编码方式，而不是一个加密算法，用GTMBase64三方库</p></li><li><p>MD5加密:Message-Digest Algorithm 5，严格来说是一种摘要算法，MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值</p></li><li><p>DES加密:Data Encryption Standard：对称算法，数据加密标准，速度较快，适用于加密大量数据的场合；</p></li><li><p>HMAC加密算法：依赖于CommonCryptor库.主要应用于身份验证，为了防止匿名攻击，服务器需要确保每个请求都是从被信任的客户端发起的</p><h6 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h6><ol><li>客户端发出登录请求</li><li>服务器返回一个随机值（key），在会话记录中保存这个随机值</li><li>客户端将该随机值作为密钥，用户密码进行 hmac 运算，递交给服务器</li><li>服务器读取数据库中的用户密码，利用密钥做和客户端一样的hmac运算，然后与用户发送的结果比较，如果一致，则用户身份合法。</li></ol></li><li><p>RSA加密:非对称加密算法，加密的密钥和解密的秘钥不相同；</p><pre><code>公钥，可以对外给任何人的加密和解密密码，公开的，可以任何人访问私钥，私钥是一定要严格保护的，通过私钥可以生成公钥，但是从公钥可以认为是永远无法推导出私钥的</code></pre><h6 id="RSA加密主要包含-密钥生成算法、加密算法和解密算法三部"><a href="#RSA加密主要包含-密钥生成算法、加密算法和解密算法三部" class="headerlink" title="RSA加密主要包含 密钥生成算法、加密算法和解密算法三部"></a>RSA加密主要包含 密钥生成算法、加密算法和解密算法三部</h6><pre><code>1.  通过密钥生成算法生成公钥(Public Key)和私钥(Primary Key)，公钥一般公开给客户端，私钥由服务器保留2.  客户端通过公钥进行加密，传给服务端3.  服务端收到客户端数据包之后用私钥解密得到对应数据</code></pre><h6 id="RSA签名（认证）主要包含-密钥生成算法、签名算法和验证算法"><a href="#RSA签名（认证）主要包含-密钥生成算法、签名算法和验证算法" class="headerlink" title="RSA签名（认证）主要包含 密钥生成算法、签名算法和验证算法"></a>RSA签名（认证）主要包含 密钥生成算法、签名算法和验证算法</h6><pre><code>1.  通RSA加密相同的生成公钥(Public Key)和私钥(Primary Key)2.  通过私钥和数据包（一般为文件）进行加密,实现对文件的签名3.  将数据包（文件）通过公钥解密，验证签名</code></pre></li></ul><hr><h3 id="苹果证书"><a href="#苹果证书" class="headerlink" title="苹果证书"></a>苹果证书</h3><h4 id="证书类型"><a href="#证书类型" class="headerlink" title="证书类型"></a>证书类型</h4><ul><li style="list-style: none"><input type="checkbox"> 开发证书:一般为99证书，开发真机调试用</li><li style="list-style: none"><input type="checkbox"> 发布证书：app发布到appstore时候打包使用</li><li style="list-style: none"><input type="checkbox"> 推送证书：ConnectCenter创建推送证书，注册推送功能</li><li style="list-style: none"><input type="checkbox"> 企业证书：299证书，不需要发布到appstore，打包信任后即可安装</li></ul><h4 id="证书申请使用"><a href="#证书申请使用" class="headerlink" title="证书申请使用"></a>证书申请使用</h4><ol><li>开发者使用Mac电脑像CA机构创建证书申请，本地会生成csr文件，同时秘钥保存在本地（后续打发布的包用于Xcode验证）</li><li>开发者在ConnectCenter上传csr文件申请证书，并下载到本地，双击打开后从钥匙串生成.p12文件可用于其他设备打包发布</li><li>生成成provisioning profile时选择对应的证书，然后下载安装相应的provisioning文件（称描述文件），描述文件包含公钥、设备信息、开发者信息、过期信息等等；</li><li>在程序打包时，会用私钥就代码进行加密，然后把provisioning文件包含到app文件中。当iOS设备安装应用时，首先用CA的公钥解密出开发者的公钥，然后再用开发者的公钥解密出代码，完成安装</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;加密算法&quot;&gt;&lt;a href=&quot;#加密算法&quot; class=&quot;headerlink&quot; title=&quot;加密算法&quot;&gt;&lt;/a&gt;加密算法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;base_64加密:最常见的用于传输8位字节代码的编码方式之一。更多的感觉Base_64是作为一个字符编码
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS开发之状态栏导航栏</title>
    <link href="https://yuweizhong.github.io/yu.github.io/2017/08/26/iOS%E5%BC%80%E5%8F%91%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A0%8F%E5%AF%BC%E8%88%AA%E6%A0%8F/"/>
    <id>https://yuweizhong.github.io/yu.github.io/2017/08/26/iOS开发之状态栏导航栏/</id>
    <published>2017-08-26T10:41:44.000Z</published>
    <updated>2017-08-31T10:50:56.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS开发之状态栏导航栏"><a href="#iOS开发之状态栏导航栏" class="headerlink" title="iOS开发之状态栏导航栏"></a><strong>iOS开发之状态栏导航栏</strong></h1><hr><h1 id="​状态栏"><a href="#​状态栏" class="headerlink" title="​状态栏"></a><code>​</code>状态栏</h1><h2 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h2><p>将info.plist文件的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Viewcontroller-based status bar ppearance</div></pre></td></tr></table></figure></p><p>设置为NO，即可开启全局设置，也就是说你在VC中对状态栏的控制都将无效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//设置状态栏的字体颜色模式</div><div class="line">&gt; [[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent];</div><div class="line">//设置状态栏是否隐藏</div><div class="line">[[UIApplication sharedApplication] setStatusBarHidden:YES];</div><div class="line">UIStatusBarStyleDefault和UIStatusBarStyleLightContent，前者是默认的黑色，而后者是白色。</div></pre></td></tr></table></figure></p><h2 id="分页面设置"><a href="#分页面设置" class="headerlink" title="分页面设置"></a>分页面设置</h2><p>将info.plist文件的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Viewcontroller-based status bar ppearance</div></pre></td></tr></table></figure></p><p>设置为YES，即可开启由VC来控制状态栏的功能，在这种模式下，全局的设置将无效！！所以我们必须逐个页面对状态栏进行设置，否则状态栏将维持默认的黑色字体和默认为显示状态。<br>1) 当VC不在UINavigationController中时，在VC中添加一个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (UIStatusBarStyle)preferredStatusBarStyle</div><div class="line">&#123;</div><div class="line"> //返回白色</div><div class="line"> return UIStatusBarStyleLightContent;</div><div class="line"> //返回黑色</div><div class="line"> //return UIStatusBarStyleDefault;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>保险起见，在view的某个加载阶段比如viewWillAppear中，执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self setNeedsStatusBarAppearanceUpdate];</div></pre></td></tr></table></figure></p><p>2) 当VC在UINavigationController中时，VC并不能通过1)的方式控制状态栏的颜色，详见本文后面的参考资料，那么这个时候，有一个trick的方法可以在VC中间接的控制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.navigationController.navigationBar.barStyle = UIBarStyleBlack;</div></pre></td></tr></table></figure></p><h1 id="导航栏"><a href="#导航栏" class="headerlink" title="##导航栏"></a>##导航栏</h1><p>导航栏背景控制 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[UINavigationBar appearance] setBarTintColor:[UIColor yellowColor]];</div></pre></td></tr></table></figure></p><p>导航栏背景图片 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[UINavigationBar appearance] setBackgroundImage:[UIImage imageNamed:@ &quot;nav_bg.png&quot; ]  forBarMetrics:UIBarMetricsDefault]; （图片64px覆盖状态栏）</div></pre></td></tr></table></figure><p>导航栏标题设置 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSShadow *shadow = [[NSShadow alloc] init]; </div><div class="line"> shadow.shadowColor = [UIColor colorWithRed:0.0 green:0.0 blue:0.0 alpha:0.8]; </div><div class="line"> shadow.shadowOffset = CGSizeMake(0, 1); </div><div class="line"> [[UINavigationBar appearance] setTitleTextAttributes: [NSDictionary dictionaryWithObjectsAndKeys: </div><div class="line"> [UIColor colorWithRed:245.0/255.0 green:245.0/255.0 blue:245.0/255.0 alpha:1.0], NSForegroundColorAttributeName, </div><div class="line"> shadow, NSShadowAttributeName, </div><div class="line"> [UIFont fontWithName:@ &quot;HelveticaNeue-CondensedBlack&quot; size:21.0], NSFontAttributeName, nil]];</div></pre></td></tr></table></figure></p><p>导航栏按钮颜色设置 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[UINavigationBar appearance] setTintColor:[UIColor whiteColor]];</div></pre></td></tr></table></figure></p><p>导航栏下控件定位 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">self.automaticallyAdjustsScrollViewInsets =NO;（scrollView布局设置）</div><div class="line">if (on) &#123; (控件自动下移64)</div><div class="line"></div><div class="line"> self.edgesForExtendedLayout = UIRectEdgeNone;</div><div class="line"></div><div class="line"> &#125;else&#123;</div><div class="line"></div><div class="line"> self.edgesForExtendedLayout = UIRectEdgeAll;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>导航栏图标左移<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//创建UIBarButtonSystemItemFixedSpace</div><div class="line">UIBarButtonItem * spaceItem = [[UIBarButtonItem alloc]initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace target:nil action:nil];</div><div class="line">//将宽度设为负值</div><div class="line">spaceItem.width = -15;</div><div class="line">//将两个BarButtonItem都返回给NavigationItem</div><div class="line">self.navigationItem.leftBarButtonItems = @[spaceItem,leftBarBtn];</div></pre></td></tr></table></figure></p><p>全屏滑动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">id target = self.interactivePopGestureRecognizer.delegate;</div><div class="line">// 创建全屏滑动手势，调用系统自带滑动手势的target的action方法</div><div class="line"> UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:target action:@selector(handleNavigationTransition:)];</div><div class="line"> // 设置手势代理，拦截手势触发</div><div class="line">pan.delegate = self;</div><div class="line">// 给导航控制器的view添加全屏滑动手势</div><div class="line">  [self.view addGestureRecognizer:pan];</div><div class="line"> // 禁止使用系统自带的滑动手势</div><div class="line">self.interactivePopGestureRecognizer.enabled = NO;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS开发之状态栏导航栏&quot;&gt;&lt;a href=&quot;#iOS开发之状态栏导航栏&quot; class=&quot;headerlink&quot; title=&quot;iOS开发之状态栏导航栏&quot;&gt;&lt;/a&gt;&lt;strong&gt;iOS开发之状态栏导航栏&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;​状态
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>First Blog</title>
    <link href="https://yuweizhong.github.io/yu.github.io/2017/08/21/FirstBlog/"/>
    <id>https://yuweizhong.github.io/yu.github.io/2017/08/21/FirstBlog/</id>
    <published>2017-08-21T10:42:06.000Z</published>
    <updated>2017-08-21T11:58:22.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo-GitHub"><a href="#hexo-GitHub" class="headerlink" title="hexo+GitHub"></a><strong>hexo+GitHub</strong></h1><p> 很早就有写博客这个想法，希望有一个个人的独立博客，最后采用了hexo+github的方式建立了这个个人博客。</p><h2 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h2><p>hexo是一款基于Node.js的静态博客框架，和jekyll相似，鉴于hexo以下优点，最后，使用了hexo作为博客框架</p><ol><li>依赖少（仅依赖node），易于安装</li><li>台湾人写的，不用担心对中文支持不好</li><li>对程序员友好，要是愿意折腾还是有的折腾的</li></ol><h2 id="构建博客步骤"><a href="#构建博客步骤" class="headerlink" title="构建博客步骤"></a>构建博客步骤</h2><ul><li>安装Git Bash</li><li>安装node.js<br>++（傻瓜式安装不多做解释）++</li><li>创建文件夹作仓库（例如blog目录）进入到该目录 </li><li>安装hexo： npm i -g hexo </li><li>初始化：hexo init<h3 id="生成目录"><a href="#生成目录" class="headerlink" title="生成目录"></a>生成目录</h3></li><li style="list-style: none"><input type="checkbox"> node_modules：是依赖包</li><li style="list-style: none"><input type="checkbox"> public：存放的是生成的页面</li><li style="list-style: none"><input type="checkbox"> scaffolds：命令生成文章等的模板</li><li style="list-style: none"><input type="checkbox"> source：用命令创建的各种文章</li><li style="list-style: none"><input type="checkbox"> themes：主题</li><li style="list-style: none"><input type="checkbox"> _config.yml：整个博客的配置</li><li style="list-style: none"><input type="checkbox"> db.json：source解析所得到的</li><li style="list-style: none"><input type="checkbox"> package.json：项目所需模块项目的配置信息</li></ul><h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><ul><li>注册github账号（已注册的忽略）</li><li>创建一个repo，名称为yourname.github.io, 其中yourname是你的github名称 </li><li>创建完之后，用编辑器打开你的blog项目，修改_config.yml文件最后的一些配置(冒号之后都是有一个半角空格的)<br>deploy:<br>type: git<br>repo: <a href="https://github.com/YourgithubName/YourgithubName.github.io.git" target="_blank" rel="external">https://github.com/YourgithubName/YourgithubName.github.io.git</a><br>branch: master</li><li>回到gitbash中，进入你的blog目录，分别执行以下命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo clean</div><div class="line">hexo generate</div><div class="line">hexo server</div></pre></td></tr></table></figure></li></ul><p>打开浏览器输入：<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 可以查看到博客主页</p><h2 id="上传github"><a href="#上传github" class="headerlink" title="上传github"></a>上传github</h2><ul><li><p>先安装一波：npm install hexo-deployer-git–save（这样才能将你写好的文章部署到github服务器上并让别人浏览到）</p></li><li><p>执行命令(建议每次都按照如下步骤部署)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo clean</div><div class="line">hexo generate</div><div class="line">hexo deploy</div></pre></td></tr></table></figure></li></ul><p>在浏览器中输入 <a href="http://yourgithubname.github.io" target="_blank" rel="external">http://yourgithubname.github.io</a> 就可以看到你的个人博客啦</p><h3 id="修改博客主页主题"><a href="#修改博客主页主题" class="headerlink" title="修改博客主页主题"></a>修改博客主页主题</h3><p>网址<a href="https://hexo.io/themes/" target="_blank" rel="external">https://hexo.io/themes/</a><br>github上clone到themes里面更改config配置后即可生效</p><h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo new &apos;文章名&apos;</div></pre></td></tr></table></figure><p>然后你就可以在source/_posts路径下看到你创建的文章啦，编辑完成之后按照前面说的方式部署，在浏览器刷新就能看到你的文章了。至于markdown，可以自行发挥！！！</p><hr><p>可以说，2017年是特殊的一年，从学校步入到了社会，在近两年iOS形势大败之下能够成功入职了某大型互联网金融公司，现在看来也是不错的。当然，在仔细品味大神的博客之后，对博客也萌生了更多的想法，在这后博客时代，博客是一个单纯美好的平台，一个分享、记录的平台。动笔写博客主要是想能够充实自己</p><ol><li>积累==积累一些实在的东西，踏实的继续走下去</li><li>坚持==坚持撰写博客，不断激励自己，不断进步</li><li>分享==分享一些自己学习到的技术和知识</li><li>记录==记录技术道路上的点滴<h4 id="我的博客诞生于2017年，伴随着第一份正式工作的尘埃落定。希望接下来能够坚持这个习惯，能够不断充实自己！！！"><a href="#我的博客诞生于2017年，伴随着第一份正式工作的尘埃落定。希望接下来能够坚持这个习惯，能够不断充实自己！！！" class="headerlink" title="我的博客诞生于2017年，伴随着第一份正式工作的尘埃落定。希望接下来能够坚持这个习惯，能够不断充实自己！！！"></a>我的博客诞生于2017年，伴随着第一份正式工作的尘埃落定。希望接下来能够坚持这个习惯，能够不断充实自己！！！</h4></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;hexo-GitHub&quot;&gt;&lt;a href=&quot;#hexo-GitHub&quot; class=&quot;headerlink&quot; title=&quot;hexo+GitHub&quot;&gt;&lt;/a&gt;&lt;strong&gt;hexo+GitHub&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt; 很早就有写博客这个想法，希望有一
      
    
    </summary>
    
    
  </entry>
  
</feed>
